横向加强算法M：

定义一个指标：空缺度

空缺度计算方法的详细说明：

  每个月相emoji可以表示为4个位置的模式，从左到右编号为0-3：
  - 🌑: [⚫⚫⚫⚫] - 全黑，无黄色
  - 🌘: [🟡⚫⚫⚫] - 位置0有黄色
  - 🌗: [🟡🟡⚫⚫] - 位置0-1有黄色
  - 🌖: [🟡🟡🟡⚫] - 位置0-2有黄色
  - 🌕: [🟡🟡🟡🟡] - 位置0-3有黄色（全黄）
  - 🌔: [⚫🟡🟡🟡] - 位置1-3有黄色
  - 🌓: [⚫⚫🟡🟡] - 位置2-3有黄色
  - 🌒: [⚫⚫⚫🟡] - 位置3有黄色

  空缺度n的计算规则：
  1. 当A或B中有一个是🌑时，n = -1
  2. 对于其他情况，空缺度n = 左字符A最右侧黄色位置与右字符B最左侧黄色位置之间的黑色格子数量

  具体计算步骤：
  - 找出A中最右侧的黄色位置（记为pos_A）
  - 找出B中最左侧的黄色位置（记为pos_B）
  - 如果pos_A = 3且pos_B = 0，则黄色直接相邻，n = 0
  - 否则，n = A中pos_A右侧的黑色数量 + B中pos_B左侧的黑色数量

  计算示例：
  - 【🌘,🌗】：🌘最右黄色在位置0，其右有3个黑色；🌗最左黄色在位置0，其左有0个黑色；n = 3 + 0 = 3
  - 【🌒,🌘】：🌒最右黄色在位置3，其右有0个黑色；🌘最左黄色在位置0，其左有0个黑色；且位置3和0相邻，n= 0
  - 【🌖,🌕】：🌖最右黄色在位置2，其右有1个黑色；🌕最左黄色在位置0，其左有0个黑色；n = 1 + 0 = 1
  - 【🌓,🌗】：🌓最右黄色在位置3；🌗最左黄色在位置0；位置3和0相邻，n = 0

因此，n的取值范围为【-1，6】
具体的查询表个如下：
const distances = { 
    '🌘': { '🌘': 3, '🌗': 3, '🌖': 3, '🌕': 3, '🌔': 4, '🌓': 5, '🌒': 6, '🌑': -1 }, 
    '🌗': { '🌘': 2, '🌗': 2, '🌖': 2, '🌕': 2, '🌔': 3, '🌓': 4, '🌒': 5, '🌑': -1 },    
    '🌖': { '🌘': 1, '🌗': 1, '🌖': 1, '🌕': 1, '🌔': 2, '🌓': 3, '🌒': 4, '🌑': -1 },            
    '🌕': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },            
    '🌔': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },            
    '🌓': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },            
    '🌒': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 }          
}; 


有了这个定义后，每两个水平相邻的字符之间就可以计算这个空缺度。最左侧、最右侧，由于只有一边临近其它字符，而另外一边没有临近字符，这时将没有临近字符的一边的空隙度设定为-1.
每个字符，可以分别和其左侧，右侧各计算一个空缺度（第一列和最后一列除外，它们仅有一个空缺度）


接下来，我们定义一个数值：粘合系数p（取值范围为1-6的整数）

定义一个操作：粘合操作

 指对每个字符，当它和邻近字符的空缺度不等于-1，且小于或等于粘合系数，则进行一个粘合变换：即把它们之间的空隙填满（通过更换字符，让字符间空隙被填满）

 举个例子：

 【🌗，🌖】之间n=2，当粘合系数设定为p=2，那么执行粘合操作后，变为【🌕，🌖】
 但此时【🌘，🌔】之间n=4，则它们之间粘合操作以后，并不发生任何变化。

 【🌖，🌔】之间n=2，因此此时粘合操作以后，变为【🌕，🌕】
 因此，粘合操作可能改变二者之一，也可能二者均改变，目的是要消除字符间空隙。


  当一个字符，左右两侧的空缺度都等于-1，且自身不为🌕或者🌑，那么进行自粘合：
  定义一个指标：自身空缺度{'🌔':1,'🌓':2,'🌒':3,'🌑':4,'🌘':3,'🌗':2,'🌖':1,'🌕':0}
  当自身空缺度小于等于粘合系数，那么这个字符直接变更为🌕
  举个例子：
    🌑🌖🌑，如何此时粘合系数为2，那么通过自粘合，变为🌑🌕🌑

 



定义一个操作：去噪操作

在进行完粘合操作后，对于现在每个字符，如果它左侧和右侧的两个空隙距离同时满足（大于0或者等于-1），并且这个字符本身不是🌕，那么这个字符被认为是噪点，直接置为🌑


最后，横向加强算法M，即执行一个工作流：
对生成的结果中的每个字符进行左右空隙度计算，然后对每个字符左右均进行粘合操作，最后再对结果进行去噪操作。




/*
设定字体的默认配置
字体：（噪音过滤阈值，粘合系数）
システム既定：(8,2)
ゴシック体：(8,2)
明朝体：(4,3)
*/






    更新后的密度分级对照表

  | 密度等级 | 密度范围      | 黑色像素数量  | 百分比      | 调试符号    | 生成的月相          |
  |------|-----------|---------|----------|---------|----------------|
  | 高密度  | ≥0.88     | 22-25像素 | 88%-100% | 无（保持🌕） | 🌕             |
  | 次高密度 | 0.60-0.88 | 15-21像素 | 60%-88%  | 🟨      | 🌕/🌖/🌔（根据重心） |
  | 中等密度 | 0.36-0.60 | 9-14像素  | 36%-60%  | 🟧      | 🌕/🌗/🌓（根据重心） |
  | 中低密度 | 0.20-0.36 | 5-8像素   | 20%-36%  | 🟦      | 🌕/🌘/🌒（根据重心） |
  | 极低密度 | <0.20     | 1-4像素   | 4%-20%   | ⬛       | 🌑             |


垂直化处理：对于中等、中低的情况下，如果重心计算为平衡，则增加处理：
  识别上方字符的自身空缺度{'🌔':1,'🌓':2,'🌒':3,'🌑':4,'🌘':3,'🌗':2,'🌖':1,'🌕':0}
  当上方字符空缺度大于n(n=2)时，此时字符显示🌕，否则显示🌑。
  即：当上方字符的自身空缺度 ≤n时（即🌕、🌖、🌗、🌔、🌓），当前🌕字符会避让为🌑

新增增强模式：中等密度的🌕始终保持显示，不受垂直堆叠影响
锐化模式：与增强模式互斥，选中后，次高和中等密度，都需要根据上方情况做垂直化。