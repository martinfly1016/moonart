<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ | æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆä½œæˆ | ç„¡æ–™ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›ãƒ„ãƒ¼ãƒ« - MojiMoon</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã‚’ç¾ã—ã„æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›ã™ã‚‹ç„¡æ–™ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã€‚ç¸¦æ›¸ããƒ»æ¨ªæ›¸ãå¯¾å¿œã€è¤‡æ•°ãƒ•ã‚©ãƒ³ãƒˆé¸æŠå¯èƒ½ã€‚æœˆã®æº€æ¬ ã‚’è¡¨ç¾ã—ãŸãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚¢ã‚¹ã‚­ãƒ¼ã‚¢ãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ">
    <meta name="keywords" content="æœˆæ–‡å­—,çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆ,ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ¼ãƒˆ,ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼,ç„¡æ–™ãƒ„ãƒ¼ãƒ«">
    <meta name="author" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
    <meta name="robots" content="index,follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
    <meta property="og:description" content="ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›ã™ã‚‹ç„¡æ–™ãƒ„ãƒ¼ãƒ«">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mojimoon.com/">
    <meta property="og:image" content="https://mojimoon.com/moon_icon.png">
    <meta property="og:locale" content="ja_JP">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@mojimoon">
    <meta name="twitter:title" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
    <meta name="twitter:description" content="ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›">
    <meta name="twitter:image" content="https://mojimoon.com/moon_icon.png">
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ™</text></svg>">
    <link rel="icon" type="image/png" sizes="32x32" href="/moon_icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/moon_icon.png">
    <link rel="apple-touch-icon" href="/moon_icon.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://mojimoon.com/">
    
    <!-- Domain redirect script -->
    <script>
        (function() {
            if (window.location.hostname === 'martinfly1016.github.io') {
                window.location.replace('https://mojimoon.com/');
            }
        })();
    </script>
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼",
        "description": "ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›",
        "applicationCategory": "UtilityApplication",
        "operatingSystem": "All",
        "inLanguage": "ja",
        "isAccessibleForFree": true
    }
    </script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WD9XP5ERGX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WD9XP5ERGX');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .text-input {
            width: 100%;
            height: 48px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
        }
        
        .text-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .height-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .height-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .height-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #fbbf24;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
            transition: all 0.2s ease;
        }
        
        .height-slider::-webkit-slider-thumb:hover {
            background: #f59e0b;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
        }
        
        .font-select {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            outline: none;
        }
        
        .font-select option {
            background: #4c1d95;
            color: white;
        }
        
        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
        }
        
        .preview-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            min-height: 300px;
        }
        
        .moon-art {
            font-family: monospace;
            font-size: 12px;
            line-height: 1.4;
            letter-spacing: 0.1em;
            white-space: pre;
            overflow-x: auto;
            color: #fff;
            padding-top: 5px;
        }
        
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            flex: 1;
            min-width: 140px;
        }
        
        .copy-btn {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .copy-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
        }
        
        .download-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }
        
        .download-btn:hover {
            background: linear-gradient(135deg, #1d4ed8, #1e40af);
            transform: translateY(-1px);
        }
        
        .btn-icon {
            font-size: 16px;
        }
        
        .btn-text {
            font-size: 13px;
        }
        
        .copy-btn.success {
            background: linear-gradient(135deg, #059669, #047857);
        }
        
        .direction-control {
            display: flex;
            gap: 20px;
            margin-top: 8px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .radio-option input[type="radio"],
        .radio-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #8b5cf6;
        }
        
        .radio-label {
            font-weight: 500;
        }
        
        /* ãƒ•ãƒƒã‚¿ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ« */
        .footer {
            margin-top: 40px;
            padding: 20px 15px;
        }
        
        .footer-bookmark-btn {
            background: none;
            border: none;
            color: #fbbf24;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            margin: 0 2px;
            transition: color 0.2s ease;
        }
        
        .footer-bookmark-btn:hover {
            color: #f59e0b;
        }
        
        /* æ‚¬æµ®æ”¶è—æŒ‰é’® */
        .floating-bookmark {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(251, 191, 36, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 16px;
            gap: 6px;
        }
        
        .floating-bookmark:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(251, 191, 36, 0.5);
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .header {
                margin-bottom: 15px;
            }
            
            .header h1 {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }
            
            .control-panel {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .form-group {
                margin-bottom: 15px;
            }
            
            .form-group h3 {
                font-size: 0.9rem;
                margin-bottom: 6px;
            }
            
            .floating-bookmark {
                display: none;
            }
            
            body {
                padding-top: 10px;
            }
            
            .footer h2 {
                font-size: 1.1rem;
            }
            
            /* ç§»åŠ¨ç«¯æŒ‰é’®ä¼˜åŒ– - å•è¡Œå¸ƒå±€ */
            .action-buttons {
                gap: 5px;
                flex-wrap: nowrap;
            }
            
            .action-btn {
                min-width: 0;
                padding: 8px 6px;
                font-size: 12px;
                flex: 1;
            }
            
            .btn-icon {
                font-size: 14px;
            }
            
            .btn-text {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating Bookmark Button -->
    <button id="bookmarkBtn" class="floating-bookmark" title="ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ">
        â­ ãŠæ°—ã«å…¥ã‚Š
    </button>
    
    <div class="container">
        <header class="header">
            <h1>ğŸŒ™ æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        </header>
        
        <div class="control-panel">
            <div class="form-group">
                <h3 style="margin-bottom: 8px; font-size: 1rem; font-weight: 600;">ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</h3>
                <input type="text" id="textInput" class="text-input" placeholder="å¤‰æ›ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" value="æœˆæ–‡å­—">
            </div>
            
            <div class="form-group">
                <div class="direction-control">
                    <label class="radio-option">
                        <input type="radio" name="textDirection" value="vertical">
                        <span class="radio-label">ç¸¦æ›¸ã</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="textDirection" value="horizontal">
                        <span class="radio-label">æ¨ªæ›¸ã</span>
                    </label>
                    <label class="radio-option">
                        <input type="checkbox" id="reverseColor">
                        <span class="radio-label">åè‰²</span>
                    </label>
                    <label class="radio-option">
                        <input type="checkbox" id="showVerticalInfo">
                        <span class="radio-label">å‚ç›´åŒ–æƒ…å ±</span>
                    </label>
                </div>
            </div>
            
            <div class="form-group">
                <div style="display: flex; gap: 20px; align-items: flex-start;">
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 8px; font-size: 1rem; font-weight: 600;">ãƒ•ã‚©ãƒ³ãƒˆé¸æŠ</h3>
                        <select id="fontSelect" class="font-select">
                            <option value="default" selected>ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š</option>
                            <option value="gothic">ã‚´ã‚·ãƒƒã‚¯ä½“</option>
                            <option value="mincho">æ˜æœä½“</option>
                        </select>
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">æ–‡å­—é–“éš”: <span id="spacingValue">0</span></label>
                        <div class="height-control">
                            <span>0</span>
                            <input type="range" id="spacingSlider" class="height-slider" min="0" max="20" value="0">
                            <span>20</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <label><span id="sliderLabel">é«˜ã•</span>: <span id="heightValue">10</span><span id="sliderUnit">è¡Œ</span></label>
                <div class="height-control">
                    <span>10</span>
                    <input type="range" id="heightSlider" class="height-slider" min="10" max="60" value="10">
                    <span>60</span>
                </div>
            </div>
            
            <!-- è°ƒè¯•å‚æ•°åŒºåŸŸ -->
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                <h3 style="margin-bottom: 15px; font-size: 1rem; font-weight: 600; color: #fbbf24;">è°ƒè¯•å‚æ•°</h3>
                
                <div class="form-group">
                    <label>æ¨ªå‘ç²˜åˆç³»æ•°: <span id="adhesionValue">2</span></label>
                    <div class="height-control">
                        <span>0</span>
                        <input type="range" id="adhesionSlider" class="height-slider" min="0" max="6" value="2">
                        <span>6</span>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; font-size: 0.9rem; font-weight: 600;">å‚ç›´åŒ–å¤„ç†</h4>
                    <div style="display: flex; gap: 20px;">
                        <label class="radio-option">
                            <input type="checkbox" id="verticalMedium" checked>
                            <span class="radio-label">ä¸­ç­‰å¯†åº¦</span>
                        </label>
                        <label class="radio-option">
                            <input type="checkbox" id="verticalHigh" checked>
                            <span class="radio-label">æ¬¡é«˜å¯†åº¦</span>
                        </label>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; font-size: 0.9rem; font-weight: 600;">æ¨ªå‘åŠ å¼ºç®—æ³•</h4>
                    <div style="display: flex; gap: 20px;">
                        <label class="radio-option">
                            <input type="checkbox" id="enableDenoising" checked>
                            <span class="radio-label">å»å™ªå¤„ç†</span>
                        </label>
                    </div>
                </div>
            </div>
            
            
            
            <!-- Action Buttons -->
            <div id="actionButtons" class="action-buttons" style="display: none;">
                <button id="copyBtn" class="action-btn copy-btn">
                    <span class="btn-icon">ğŸ“‹</span>
                    <span class="btn-text">ã‚³ãƒ”ãƒ¼</span>
                </button>
                <button id="downloadTextBtn" class="action-btn download-btn">
                    <span class="btn-icon">ğŸ“„</span>
                    <span class="btn-text">ãƒ†ã‚­ã‚¹ãƒˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
                </button>
                <button id="downloadImageBtn" class="action-btn download-btn">
                    <span class="btn-icon">ğŸ–¼ï¸</span>
                    <span class="btn-text">ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
                </button>
            </div>
        </div>
        
        <div class="preview-panel">
            <h2 style="margin-bottom: 8px; font-size: 12px; font-weight: 600;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
            
            <!-- Debug info for vertical processing -->
            <div id="debugInfo" style="margin-bottom: 10px; font-size: 11px; color: #fbbf24; font-family: monospace; display: none;">
                <div>å‚ç›´åŒ–å‡¦ç†: <span id="verticalProcessingStatus">æœ‰åŠ¹</span></div>
                <div>å¯¾è±¡å¯†åº¦ãƒ¬ãƒ™ãƒ«: <span id="targetDensityLevels">ä¸­ç­‰å¯†åº¦</span></div>
                <div>é–¾å€¤n: <span id="thresholdN">2</span></div>
                <div>å‡¦ç†ãƒ¢ãƒ¼ãƒ‰: <span id="processingMode">ä¸­ç­‰å¯†åº¦ï¼ˆãƒãƒ©ãƒ³ã‚¹é‡å¿ƒã®ã¿ï¼‰</span></div>
            </div>
            
            <div id="moonArt" class="moon-art"><!-- ç”ŸæˆçµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ --></div>
            
            <!-- Debug controls (hidden for production) -->
            <div style="margin-top: 20px; display: none;">
                <label>
                    <input type="checkbox" id="showDebugCanvas"> æ˜¾ç¤ºåŸå§‹Canvasè°ƒè¯•
                </label>
            </div>
            
            <!-- Debug canvas (hidden for production) -->
            <canvas id="debugCanvas" style="border: 1px solid #666; margin-top: 10px; background: white; display: none; max-width: 100%;"></canvas>
            
            
        </div>
    </div>

    <script>
        // ç®€åŒ–çš„é¢œè‰²çº§åˆ«ï¼šåªæœ‰é»‘ç™½ä¸¤è‰²
        const COLOR_LEVELS = {
            BLACK: 0,
            WHITE: 1
        };
        
        // æ¨ªå‘åŠ å¼ºç®—æ³•M - æ¨¡å—åŒ–å®ç°
        class HorizontalEnhancer {
            constructor() {
                this.adhesionCoefficient = 2; // é»˜è®¤ç²˜åˆç³»æ•°
                this.enableDenoising = true; // é»˜è®¤å¯ç”¨å»å™ªå¤„ç†
                this.gapDistanceMap = this.initGapDistanceMap();
                
                // è‡ªèº«ç©ºç¼ºåº¦æ˜ å°„è¡¨
                this.selfGapMap = {
                    'ğŸŒ”': 1,
                    'ğŸŒ“': 2, 
                    'ğŸŒ’': 3,
                    'ğŸŒ‘': 4,
                    'ğŸŒ˜': 3,
                    'ğŸŒ—': 2,
                    'ğŸŒ–': 1,
                    'ğŸŒ•': 0
                };
            }
            
            // è®¾ç½®ç²˜åˆç³»æ•°
            setAdhesionCoefficient(coefficient) {
                this.adhesionCoefficient = coefficient;
            }
            
            // è®¾ç½®å»å™ªå¼€å…³
            setEnableDenoising(enable) {
                this.enableDenoising = enable;
            }
            
            // åˆå§‹åŒ–ç©ºç¼ºåº¦æŸ¥æ‰¾è¡¨
            initGapDistanceMap() {
                // åŸºäºç®—æ³•å®šä¹‰æ¨å¯¼çš„å®Œæ•´ç©ºç¼ºåº¦è¡¨
                const map = {};
                const moons = ['ğŸŒ‘', 'ğŸŒ˜', 'ğŸŒ—', 'ğŸŒ–', 'ğŸŒ•', 'ğŸŒ”', 'ğŸŒ“', 'ğŸŒ’'];
                
                // ğŸŒ‘ä¸ä»»ä½•å­—ç¬¦çš„ç©ºç¼ºåº¦éƒ½æ˜¯-1
                map['ğŸŒ‘'] = {};
                for (const moon of moons) {
                    map['ğŸŒ‘'][moon] = -1;
                }
                
                // å…¶ä»–æœˆç›¸ä¹‹é—´çš„ç©ºç¼ºåº¦
                const distances = {
                    'ğŸŒ˜': { 'ğŸŒ˜': 3, 'ğŸŒ—': 3, 'ğŸŒ–': 3, 'ğŸŒ•': 3, 'ğŸŒ”': 4, 'ğŸŒ“': 5, 'ğŸŒ’': 6, 'ğŸŒ‘': -1 },
                    'ğŸŒ—': { 'ğŸŒ˜': 2, 'ğŸŒ—': 2, 'ğŸŒ–': 2, 'ğŸŒ•': 2, 'ğŸŒ”': 3, 'ğŸŒ“': 4, 'ğŸŒ’': 5, 'ğŸŒ‘': -1 },
                    'ğŸŒ–': { 'ğŸŒ˜': 1, 'ğŸŒ—': 1, 'ğŸŒ–': 1, 'ğŸŒ•': 1, 'ğŸŒ”': 2, 'ğŸŒ“': 3, 'ğŸŒ’': 4, 'ğŸŒ‘': -1 },
                    'ğŸŒ•': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
                    'ğŸŒ”': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
                    'ğŸŒ“': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
                    'ğŸŒ’': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 }
                };
                
                return { ...map, ...distances };
            }
            
            // è®¡ç®—ä¸¤ä¸ªæœˆç›¸ä¹‹é—´çš„ç©ºç¼ºåº¦
            getGapDistance(left, right) {
                return this.gapDistanceMap[left]?.[right] || 0;
            }
            
            // æ‰§è¡Œç²˜åˆæ“ä½œ - æ ¹æ®æœ€å°‘æ›´æ¢åŸåˆ™
            performAdhesion(left, right) {
                const gap = this.getGapDistance(left, right);
                if (gap <= 0 || gap > this.adhesionCoefficient) {
                    return [left, right];
                }
                
                // å°è¯•å„ç§å¡«å……æ–¹æ¡ˆï¼Œé€‰æ‹©æ›´æ¢æœ€å°‘çš„
                const fillOptions = [
                    ['ğŸŒ•', right], // å·¦è¾¹å˜æ»¡æœˆ
                    [left, 'ğŸŒ•'],  // å³è¾¹å˜æ»¡æœˆ
                    ['ğŸŒ•', 'ğŸŒ•']   // ä¸¤è¾¹éƒ½å˜æ»¡æœˆ
                ];
                
                // ä¼˜å…ˆé€‰æ‹©åªæ”¹å˜ä¸€è¾¹çš„æ–¹æ¡ˆ
                for (const [newLeft, newRight] of fillOptions) {
                    if (this.getGapDistance(newLeft, newRight) === 0) {
                        // å¦‚æœåªéœ€è¦æ”¹å˜ä¸€è¾¹ï¼Œä¼˜å…ˆé€‰æ‹©
                        if (newLeft !== left && newRight === right) {
                            return [newLeft, newRight];
                        }
                        if (newLeft === left && newRight !== right) {
                            return [newLeft, newRight];
                        }
                    }
                }
                
                // å¦‚æœå¿…é¡»æ”¹å˜ä¸¤è¾¹ï¼Œè¿”å›åŒæ»¡æœˆ
                return ['ğŸŒ•', 'ğŸŒ•'];
            }
            
            // è‡ªç²˜åˆæ“ä½œ
            selfAdhesion(lines) {
                const processedLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        processedLines.push(line);
                        continue;
                    }
                    
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    for (let i = 0; i < chars.length; i++) {
                        const current = chars[i];
                        
                        // è·³è¿‡ğŸŒ•å’ŒğŸŒ‘
                        if (current === 'ğŸŒ•' || current === 'ğŸŒ‘') {
                            continue;
                        }
                        
                        // æ£€æŸ¥å·¦å³ä¸¤ä¾§æ˜¯å¦éƒ½æ˜¯ğŸŒ‘ï¼ˆç©ºç¼ºåº¦ä¸º-1ï¼‰
                        let leftIsEmpty = false, rightIsEmpty = false;
                        
                        if (i === 0) {
                            leftIsEmpty = true; // æœ€å·¦ä¾§è§†ä¸º-1
                        } else {
                            leftIsEmpty = (chars[i - 1] === 'ğŸŒ‘');
                        }
                        
                        if (i === chars.length - 1) {
                            rightIsEmpty = true; // æœ€å³ä¾§è§†ä¸º-1
                        } else {
                            rightIsEmpty = (chars[i + 1] === 'ğŸŒ‘');
                        }
                        
                        // å¦‚æœå·¦å³ä¸¤ä¾§éƒ½æ˜¯ç©ºç¼ºï¼ˆ-1ï¼‰ï¼Œæ‰§è¡Œè‡ªç²˜åˆæ£€æŸ¥
                        if (leftIsEmpty && rightIsEmpty) {
                            const selfGap = this.selfGapMap[current] || 0;
                            if (selfGap <= this.adhesionCoefficient) {
                                newChars[i] = 'ğŸŒ•';
                            }
                        }
                    }
                    
                    processedLines.push(newChars.join(''));
                }
                
                return processedLines;
            }
            
            // ä¸»å¤„ç†å‡½æ•° - æ¨ªå‘åŠ å¼º
            enhance(moonArtText) {
                if (this.adhesionCoefficient === 0) {
                    return moonArtText;
                }
                
                const lines = moonArtText.split('\n');
                const processedLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        processedLines.push(line);
                        continue;
                    }
                    
                    // å°†emojiå­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°ç»„ï¼ˆå¤„ç†2å­—èŠ‚emojiï¼‰
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    // ä»å·¦åˆ°å³æ‰§è¡Œç²˜åˆæ“ä½œ
                    for (let i = 0; i < chars.length - 1; i++) {
                        const [newLeft, newRight] = this.performAdhesion(newChars[i], newChars[i + 1]);
                        newChars[i] = newLeft;
                        newChars[i + 1] = newRight;
                    }
                    
                    processedLines.push(newChars.join(''));
                }
                
                // æ‰§è¡Œè‡ªç²˜åˆæ“ä½œ
                const selfAdhesedLines = this.selfAdhesion(processedLines);
                
                // æ ¹æ®å¼€å…³å†³å®šæ˜¯å¦æ‰§è¡Œå»å™ªæ“ä½œ
                if (this.enableDenoising) {
                    return this.denoise(selfAdhesedLines);
                } else {
                    return selfAdhesedLines.join('\n');
                }
            }
            
            // å»å™ªæ“ä½œ
            denoise(lines) {
                const denoiseLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        denoiseLines.push(line);
                        continue;
                    }
                    
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    for (let i = 0; i < chars.length; i++) {
                        const current = chars[i];
                        if (current === 'ğŸŒ‘') continue;
                        
                        // æ£€æŸ¥å·¦å³ä¸¤ä¾§çš„ç©ºç¼ºåº¦
                        let leftGap = -1, rightGap = -1;
                        
                        if (i > 0) {
                            leftGap = this.getGapDistance(chars[i - 1], current);
                        }
                        if (i < chars.length - 1) {
                            rightGap = this.getGapDistance(current, chars[i + 1]);
                        }
                        
                        // å¦‚æœä¸¤ä¾§ç©ºç¼ºåº¦éƒ½æ»¡è¶³ï¼ˆå¤§äº0æˆ–ç­‰äº-1ï¼‰ä¸”ä¸æ˜¯ğŸŒ•ï¼Œè®¤ä¸ºæ˜¯å™ªç‚¹
                        if (current !== 'ğŸŒ•' && 
                            (leftGap > 0 || leftGap === -1) && 
                            (rightGap > 0 || rightGap === -1)) {
                            newChars[i] = 'ğŸŒ‘';
                        }
                    }
                    
                    denoiseLines.push(newChars.join(''));
                }
                
                return denoiseLines.join('\n');
            }
        }
        
        class SimpleMoonGenerator {
            constructor() {
                // åŸºç¡€æœˆç›¸æ¨¡å¼ï¼šåŸºäºé»‘è‰²åƒç´ æ•°é‡çš„åˆ†å¸ƒ
                this.moonPhases = [
                    { emoji: 'ğŸŒ‘', minBlack: 0, maxBlack: 0 },    // å…¨ç™½/ç©º
                    { emoji: 'ğŸŒ˜', minBlack: 1, maxBlack: 4 },    // å¾ˆå°‘é»‘è‰² 
                    { emoji: 'ğŸŒ—', minBlack: 5, maxBlack: 8 },    // å°‘é‡é»‘è‰²
                    { emoji: 'ğŸŒ–', minBlack: 9, maxBlack: 12 },   // ä¸­ç­‰é»‘è‰²
                    { emoji: 'ğŸŒ•', minBlack: 13, maxBlack: 16 }   // å¤§é‡é»‘è‰²
                ];
                
                // å‚ç›´åŒ–å¤„ç†è®°å½•ï¼šå­˜å‚¨è¢«å¤„ç†å­—ç¬¦çš„ä½ç½®å’Œå¯†åº¦ä¿¡æ¯
                this.verticalProcessingPositions = [];
            }
            
            // æœ€ç®€å•çš„ç°åº¦å€¼è½¬æ¢ï¼šåªæœ‰é»‘ç™½ä¸¤è‰²
            grayToColorLevel(gray) {
                return gray < 128 ? 0 : 1; // 0 = é»‘è‰²ï¼Œ1 = ç™½è‰²
            }
            
            // åŸºäº5x5ç½‘æ ¼çš„æ–°å¯†åº¦åˆ†çº§æœˆç›¸è½¬æ¢ç³»ç»Ÿï¼ˆå¸¦å…ƒæ•°æ®ï¼‰
            gridToMoonWithMeta(grid) {
                // ç»Ÿè®¡5x5ç½‘æ ¼ä¸­é»‘è‰²åƒç´ ï¼ˆ0ï¼‰çš„æ•°é‡
                let blackCount = 0;
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (grid[y][x] === 0) { // 0 = é»‘è‰²
                            blackCount++;
                        }
                    }
                }
                
                // è·å–å¯†åº¦ç­‰çº§ä¿¡æ¯
                const densityLevel = this.getDensityLevel(blackCount);
                
                // è®¡ç®—æ°´å¹³é‡å¿ƒå’Œåå‘
                const centerX = this.calculateHorizontalCenter(grid);
                const bias = this.getBias(centerX);
                
                // æ ¹æ®å¯†åº¦ç­‰çº§å’Œåå‘é€‰æ‹©åŸå§‹æœˆç›¸
                let originalMoonPhase;
                switch (densityLevel.name) {
                    case 'æä½å¯†åº¦':
                        originalMoonPhase = 'ğŸŒ‘';
                        break;
                    case 'é«˜å¯†åº¦':
                        originalMoonPhase = 'ğŸŒ•';
                        break;
                    case 'ä¸­ä½å¯†åº¦':
                    case 'ä¸­ç­‰å¯†åº¦':
                    case 'æ¬¡é«˜å¯†åº¦':
                        originalMoonPhase = this.selectMoonPhase(densityLevel.name, bias);
                        break;
                    default:
                        originalMoonPhase = 'ğŸŒ‘';
                }
                
                // è¿”å›å®Œæ•´çš„å…ƒæ•°æ®
                return {
                    originalMoonPhase: originalMoonPhase,
                    finalMoonPhase: originalMoonPhase, // åˆå§‹æ—¶ä¸åŸå§‹æœˆç›¸ç›¸åŒ
                    densityLevel: densityLevel.name,
                    densitySymbol: densityLevel.debugSymbol,
                    bias: bias,
                    blackCount: blackCount,
                    centerX: centerX
                };
            }
            
            // åŸºäº5x5ç½‘æ ¼çš„æ–°å¯†åº¦åˆ†çº§æœˆç›¸è½¬æ¢ç³»ç»Ÿï¼ˆå‘åå…¼å®¹ï¼‰
            gridToMoon(grid) {
                return this.gridToMoonWithMeta(grid).finalMoonPhase;
            }
            
            // è·å–å¯†åº¦ç­‰çº§
            getDensityLevel(blackCount) {
                const densityLevels = [
                    { name: 'æä½å¯†åº¦', minPixels: 1, maxPixels: 4, debugSymbol: 'â¬›' },
                    { name: 'ä¸­ä½å¯†åº¦', minPixels: 5, maxPixels: 8, debugSymbol: 'ğŸŸ¦' },
                    { name: 'ä¸­ç­‰å¯†åº¦', minPixels: 9, maxPixels: 14, debugSymbol: 'ğŸŸ§' },
                    { name: 'æ¬¡é«˜å¯†åº¦', minPixels: 15, maxPixels: 21, debugSymbol: 'ğŸŸ¨' },
                    { name: 'é«˜å¯†åº¦', minPixels: 22, maxPixels: 25, debugSymbol: 'æ— ' }
                ];
                
                if (blackCount === 0) {
                    return { name: 'ç©ºç™½', debugSymbol: 'â¬œ' };
                }
                
                for (const level of densityLevels) {
                    if (blackCount >= level.minPixels && blackCount <= level.maxPixels) {
                        return level;
                    }
                }
                
                // è¶…å‡ºèŒƒå›´ï¼Œé»˜è®¤ä¸ºé«˜å¯†åº¦
                return densityLevels[4];
            }
            
            // è®¡ç®—5x5ç½‘æ ¼çš„æ°´å¹³é‡å¿ƒ
            calculateHorizontalCenter(grid) {
                let weightedX = 0;
                let totalBlack = 0;
                
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (grid[y][x] === 0) { // 0 = é»‘è‰²
                            weightedX += x;
                            totalBlack++;
                        }
                    }
                }
                
                return totalBlack > 0 ? weightedX / totalBlack : 2; // 5x5ä¸­å¿ƒä¸º2
            }
            
            // åˆ¤æ–­é‡å¿ƒåå‘
            getBias(centerX) {
                if (centerX < 1.8) {
                    return 'left';
                } else if (centerX > 2.2) {
                    return 'right';
                } else {
                    return 'balanced';
                }
            }
            
            // æ ¹æ®å¯†åº¦ç­‰çº§å’Œåå‘é€‰æ‹©æœˆç›¸
            selectMoonPhase(densityLevel, bias) {
                const phaseMap = {
                    'ä¸­ä½å¯†åº¦': { left: 'ğŸŒ˜', right: 'ğŸŒ’', balanced: 'ğŸŒ•' },
                    'ä¸­ç­‰å¯†åº¦': { left: 'ğŸŒ—', right: 'ğŸŒ“', balanced: 'ğŸŒ•' },
                    'æ¬¡é«˜å¯†åº¦': { left: 'ğŸŒ–', right: 'ğŸŒ”', balanced: 'ğŸŒ•' }
                };
                
                return phaseMap[densityLevel]?.[bias] || 'ğŸŒ•';
            }
            
            // æœˆç›¸åè‰²å¤„ç†
            reverseMoon(emoji) {
                const reverseMap = {
                    'ğŸŒ‘': 'ğŸŒ•', // æ–°æœˆ â†” æ»¡æœˆ
                    'ğŸŒ’': 'ğŸŒ–', // è›¾æœˆ â†” äºæœˆ
                    'ğŸŒ“': 'ğŸŒ—', // ä¸Šå¼¦æœˆ â†” ä¸‹å¼¦æœˆ
                    'ğŸŒ”': 'ğŸŒ˜', // å‡¸æœˆ â†” æ®‹æœˆ
                    'ğŸŒ•': 'ğŸŒ‘', // æ»¡æœˆ â†” æ–°æœˆ
                    'ğŸŒ–': 'ğŸŒ’', // äºæœˆ â†” è›¾æœˆ
                    'ğŸŒ—': 'ğŸŒ“', // ä¸‹å¼¦æœˆ â†” ä¸Šå¼¦æœˆ
                    'ğŸŒ˜': 'ğŸŒ”'  // æ®‹æœˆ â†” å‡¸æœˆ
                };
                return reverseMap[emoji] || emoji;
            }
            
            // å‚ç›´åŒ–å¤„ç†ï¼šå­—ç¬¦ç©ºç¼ºåº¦æ˜ å°„è¡¨
            getCharacterVacancy(moonPhase) {
                // å¢å¼ºçš„å­—ç¬¦è§„èŒƒåŒ–å¤„ç†
                let normalizedPhase = moonPhase.normalize('NFC').replace(/[\uFE0E\uFE0F]/g, '').trim();
                
                // ä½¿ç”¨å­—ç¬¦ç ç‚¹è¿›è¡Œç²¾ç¡®åŒ¹é…
                const vacancyMapByCodePoint = {
                    0x1F314: 1, // ğŸŒ”
                    0x1F313: 2, // ğŸŒ“  
                    0x1F312: 3, // ğŸŒ’
                    0x1F311: 4, // ğŸŒ‘
                    0x1F318: 3, // ğŸŒ˜
                    0x1F317: 2, // ğŸŒ—
                    0x1F316: 1, // ğŸŒ–
                    0x1F315: 0  // ğŸŒ•
                };
                
                // ä¼˜å…ˆä½¿ç”¨ç ç‚¹åŒ¹é…
                const codePoint = normalizedPhase.codePointAt(0);
                if (codePoint && vacancyMapByCodePoint.hasOwnProperty(codePoint)) {
                    return vacancyMapByCodePoint[codePoint];
                }
                
                // å¤‡ç”¨å­—ç¬¦ä¸²åŒ¹é…
                const vacancyMap = {
                    'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': 4,
                    'ğŸŒ˜': 3, 'ğŸŒ—': 2, 'ğŸŒ–': 1, 'ğŸŒ•': 0
                };
                
                return vacancyMap[normalizedPhase] || 4; // é»˜è®¤ä¸ºæœ€é«˜ç©ºç¼ºåº¦
            }
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦å‚ç›´åŒ–å¤„ç†
            shouldApplyVerticalProcessing(cellMeta, targetDensityLevels) {
                return targetDensityLevels.includes(cellMeta.densityLevel) && 
                       cellMeta.bias === 'balanced';
            }
            
            // ä»ä¸Šåˆ°ä¸‹è¿›è¡Œå‚ç›´åŒ–å¤„ç†
            applyVerticalProcessing(gridWithMeta, targetDensityLevels, thresholdN = 2) {
                const gridHeight = gridWithMeta.length;
                const gridWidth = gridWithMeta[0]?.length || 0;
                
                // æ¸…ç©ºä¹‹å‰çš„è®°å½•
                this.verticalProcessingPositions = [];
                
                
                
                
                
                // ä»ç¬¬2è¡Œå¼€å§‹å¤„ç†ï¼ˆç¬¬1è¡Œæ²¡æœ‰ä¸Šæ–¹å­—ç¬¦ï¼‰
                for (let row = 1; row < gridHeight; row++) {
                    for (let col = 0; col < gridWidth; col++) {
                        const currentCell = gridWithMeta[row][col];
                        
                        
                        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‚ç›´åŒ–å¤„ç†
                        if (this.shouldApplyVerticalProcessing(currentCell, targetDensityLevels)) {
                            
                            
                            // è®°å½•è¢«å‚ç›´åŒ–å¤„ç†çš„ä½ç½®å’Œå¯†åº¦ä¿¡æ¯
                            this.verticalProcessingPositions.push({
                                row: row,
                                col: col,
                                densityLevel: currentCell.densityLevel
                            });
                            
                            const aboveCell = gridWithMeta[row - 1][col];
                            const aboveVacancy = this.getCharacterVacancy(aboveCell.finalMoonPhase);
                            
                            
                            // ç»Ÿä¸€ä½¿ç”¨ç©ºç¼ºåº¦åˆ¤æ–­
                            if (aboveVacancy <= thresholdN) {
                                currentCell.finalMoonPhase = 'ğŸŒ‘';
                            } else {
                                currentCell.finalMoonPhase = 'ğŸŒ•';
                            }
                            
                        }
                        // ä¸éœ€è¦å‚ç›´åŒ–å¤„ç†çš„å­—ç¬¦ä¿æŒåŸæœ‰finalMoonPhaseä¸å˜
                    }
                }
                
                
                return gridWithMeta;
            }
            
            // å¯†åº¦ç­‰çº§è°ƒè¯•ç¬¦å·æ˜ å°„
            getDensityDebugSymbol(densityLevel) {
                const DENSITY_DEBUG_SYMBOLS = {
                    'ä¸­ç­‰å¯†åº¦': 'ğŸŸ§',  // æ©™è‰²æ–¹å—
                    'ä¸­ä½å¯†åº¦': 'ğŸŸ¦',  // è“è‰²æ–¹å—  
                    'æ¬¡é«˜å¯†åº¦': 'ğŸŸ¨',  // é»„è‰²æ–¹å—
                    'æä½å¯†åº¦': 'â¬›',  // é»‘è‰²æ–¹å—
                    'é«˜å¯†åº¦': 'ğŸŒ•'     // ä¿æŒåŸæ ·
                };
                
                return DENSITY_DEBUG_SYMBOLS[densityLevel] || 'â“';
            }
            
            // åº”ç”¨å‚ç›´åŒ–è°ƒè¯•ç¬¦å·æ˜¾ç¤º
            applyVerticalDebugSymbols(resultText) {
                if (this.verticalProcessingPositions.length === 0) {
                    return resultText;
                }
                
                
                const lines = resultText.split('\n');
                const resultLines = [...lines];
                
                // éå†æ‰€æœ‰è¢«å‚ç›´åŒ–å¤„ç†çš„ä½ç½®ï¼Œæ›¿æ¢ä¸ºè°ƒè¯•ç¬¦å·ï¼ˆæ˜¾ç¤ºå¤„ç†çŠ¶æ€ï¼‰
                for (const position of this.verticalProcessingPositions) {
                    const { row, col, densityLevel } = position;
                    
                    if (row < resultLines.length) {
                        const line = resultLines[row];
                        if (col < line.length) {
                            const originalChar = Array.from(line)[col];
                            let debugSymbol;
                            
                            // ç»Ÿä¸€ä½¿ç”¨å¯†åº¦ç¬¦å·ï¼Œä¸å¯¹å¤„ç†ç»“æœåšåŒºåˆ†
                            debugSymbol = this.getDensityDebugSymbol(densityLevel);
                            
                            
                            // æ›¿æ¢æŒ‡å®šä½ç½®çš„å­—ç¬¦
                            const chars = Array.from(line);
                            chars[col] = debugSymbol;
                            resultLines[row] = chars.join('');
                            
                            console.log(`è°ƒè¯•ç¬¦å·æ›¿æ¢: ä½ç½®(${row},${col}), åŸå­—ç¬¦=${originalChar}, å¯†åº¦=${densityLevel} â†’ ${debugSymbol}`);
                        }
                    }
                }
                
                return resultLines.join('\n');
            }
            
            // åº”ç”¨å­—ç¬¦é—´è·
            applySpacing(text, spacing) {
                if (spacing <= 0) return text;
                
                const lines = text.split('\n');
                const spacedLines = [];
                
                for (const line of lines) {
                    if (line.length === 0) {
                        spacedLines.push(line);
                        continue;
                    }
                    
                    // åœ¨æ¯ä¸ªå­—ç¬¦ä¹‹é—´æ’å…¥æŒ‡å®šæ•°é‡çš„ğŸŒ‘ï¼ˆç©ºæ ¼ï¼‰
                    const chars = Array.from(line);
                    const spacedChars = [];
                    
                    for (let i = 0; i < chars.length; i++) {
                        spacedChars.push(chars[i]);
                        // é™¤äº†æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œæ¯ä¸ªå­—ç¬¦åé¢éƒ½æ·»åŠ é—´è·
                        if (i < chars.length - 1) {
                            spacedChars.push('ğŸŒ‘'.repeat(spacing));
                        }
                    }
                    
                    spacedLines.push(spacedChars.join(''));
                }
                
                return spacedLines.join('\n');
            }
            
            // ç”Ÿæˆå•ä¸ªå­—ç¬¦çš„æœˆç›¸
            generateSingleChar(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
                if (!char.trim()) return [];
                
                const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
                
                // ç¬¬ä¸€é˜¶æ®µï¼šåˆ›å»ºè¶³å¤Ÿå¤§çš„canvasæ¥å®Œæ•´æ¸²æŸ“å­—ç¬¦
                const baseFontSize = Math.max(sizeParam * 5, 50); // ç¡®ä¿å­—ç¬¦è¶³å¤Ÿå¤§ï¼ˆ5x5ç³»ç»Ÿï¼‰
                const canvasWidth = baseFontSize * 2;   // ç»™å­—ç¬¦è¶³å¤Ÿçš„å®½åº¦ç©ºé—´
                const canvasHeight = baseFontSize * 2;  // ç»™å­—ç¬¦è¶³å¤Ÿçš„é«˜åº¦ç©ºé—´
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶ç™½è‰²èƒŒæ™¯
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶é»‘è‰²å­—ç¬¦
                ctx.fillStyle = 'black';
                ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const x = canvas.width / 2;
                const y = canvas.height / 2;
                ctx.fillText(char, x, y);
                
                console.log(`å­—ç¬¦ "${char}" æ¸²æŸ“: canvas=${canvasWidth}x${canvasHeight}, fontSize=${baseFontSize}`);
                
                // è·å–å›¾åƒæ•°æ®å¹¶è½¬æ¢ä¸ºåƒç´ çŸ©é˜µ
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixelMatrix = [];
                
                for (let y = 0; y < canvas.height; y++) {
                    pixelMatrix[y] = [];
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        const gray = 0.299 * imageData.data[idx] + 
                                   0.587 * imageData.data[idx + 1] + 
                                   0.114 * imageData.data[idx + 2];
                        pixelMatrix[y][x] = this.grayToColorLevel(gray);
                    }
                }
                
                // æ‰¾åˆ°å­—ç¬¦çš„å®é™…è¾¹ç•Œ
                let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
                let foundText = false;
                
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if (pixelMatrix[y][x] === 0) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            foundText = true;
                        }
                    }
                }
                
                if (!foundText) {
                    // å¦‚æœæ²¡æ‰¾åˆ°æ–‡å­—ï¼Œè¿”å›æŒ‰ç›®æ ‡å°ºå¯¸çš„é»˜è®¤çŸ©å½¢
                    if (isVertical) {
                        // ç«–å‘ï¼šå›ºå®šå®½åº¦sizeParamï¼Œé»˜è®¤é«˜åº¦3
                        const defaultLine = 'ğŸŒ•'.repeat(sizeParam);
                        return [defaultLine, defaultLine, defaultLine];
                    } else {
                        // æ¨ªå‘ï¼šå›ºå®šé«˜åº¦sizeParamï¼Œé»˜è®¤å®½åº¦3
                        const result = [];
                        for (let i = 0; i < sizeParam; i++) {
                            result.push('ğŸŒ•ğŸŒ•ğŸŒ•');
                        }
                        return result;
                    }
                }
                
                // ç¬¬äºŒé˜¶æ®µï¼šå°†å­—ç¬¦è¾¹ç•Œæ˜ å°„åˆ°ç›®æ ‡å°ºå¯¸
                const charWidth = maxX - minX + 1;
                const charHeight = maxY - minY + 1;
                
                let targetPixelWidth, targetPixelHeight;
                if (isVertical) {
                    // ç«–å‘ï¼šå›ºå®šå®½åº¦ä¸ºsizeParam*5åƒç´ ï¼Œé«˜åº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾ï¼ˆ5x5ç³»ç»Ÿï¼‰
                    targetPixelWidth = sizeParam * 5;
                    targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
                    // ç¡®ä¿é«˜åº¦æ˜¯5çš„å€æ•°
                    targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
                } else {
                    // æ¨ªå‘ï¼šå›ºå®šé«˜åº¦ä¸ºsizeParam*5åƒç´ ï¼Œå®½åº¦æŒ‰æ¯”ä¾‹ç¼©æ”¾ï¼ˆ5x5ç³»ç»Ÿï¼‰
                    targetPixelHeight = sizeParam * 5;
                    targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
                    // ç¡®ä¿å®½åº¦æ˜¯5çš„å€æ•°
                    targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
                }
                
                console.log(`å­—ç¬¦ "${char}" è¾¹ç•Œ: ${charWidth}x${charHeight} â†’ ç›®æ ‡: ${targetPixelWidth}x${targetPixelHeight}`);
                
                // ç¬¬ä¸‰é˜¶æ®µï¼šæŒ‰ç›®æ ‡å°ºå¯¸è¿›è¡Œ5x5ç½‘æ ¼æ‰«æ
                const gridSize = 5;
                const resultLines = [];
                
                for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
                    let line = '';
                    for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
                        // æå–5x5å­ç½‘æ ¼
                        const subGrid = [];
                        for (let dy = 0; dy < 5; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < 5; dx++) {
                                // å°†ç›®æ ‡åæ ‡æ˜ å°„å›åŸå§‹å­—ç¬¦åæ ‡
                                const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
                                const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
                                
                                if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
                                    subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
                                } else {
                                    subGrid[dy][dx] = 1; // ç™½è‰²
                                }
                            }
                        }
                        
                        line += this.gridToMoon(subGrid);
                    }
                    resultLines.push(line);
                }
                
                console.log(`å­—ç¬¦ "${char}" è¾“å‡º: ${resultLines[0]?.length || 0}åˆ— x ${resultLines.length}è¡Œ`);
                
                return resultLines;
            }
            
            // å‚ç›´æ‹¼æ¥å­—ç¬¦ç»“æœï¼ˆç«–å‘æ’ç‰ˆï¼‰- å­—ç¬¦ä»ä¸Šåˆ°ä¸‹æ’åˆ—
            combineVertically(charResults, spacing, sizeParam) {
                if (charResults.length === 0) return '';
                
                let combinedLines = [];
                
                for (let i = 0; i < charResults.length; i++) {
                    const charLines = charResults[i];
                    
                    // æ·»åŠ å½“å‰å­—ç¬¦çš„æ‰€æœ‰è¡Œ
                    combinedLines.push(...charLines);
                    
                    // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œæ·»åŠ é—´è·è¡Œï¼ˆæ°´å¹³åˆ†éš”ï¼‰
                    if (i < charResults.length - 1 && spacing > 0) {
                        // ä½¿ç”¨ç›®æ ‡å®½åº¦sizeParamä½œä¸ºé—´è·è¡Œå®½åº¦ï¼Œç¡®ä¿ä¸å­—ç¬¦å®½åº¦ä¸€è‡´
                        const spacingLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
                        
                        // æ·»åŠ æŒ‡å®šæ•°é‡çš„é—´è·è¡Œ
                        for (let j = 0; j < spacing; j++) {
                            combinedLines.push(spacingLine);
                        }
                    }
                }
                
                return combinedLines.join('\n');
            }
            
            // æ°´å¹³æ‹¼æ¥å­—ç¬¦ç»“æœï¼ˆæ¨ªå‘æ’ç‰ˆï¼‰
            combineHorizontally(charResults, spacing, sizeParam) {
                if (charResults.length === 0) return '';
                
                // æ‰¾å‡ºæœ€å¤§è¡Œæ•°ï¼Œç¡®ä¿æ‰€æœ‰å­—ç¬¦ç»“æœå¯¹é½
                const maxLines = Math.max(...charResults.map(result => result.length));
                
                // æ ‡å‡†åŒ–æ‰€æœ‰å­—ç¬¦ç»“æœï¼Œç¡®ä¿è¡Œæ•°ç›¸ç­‰
                const normalizedResults = charResults.map(result => {
                    const normalized = [...result];
                    // æ¨ªå‘æ’ç‰ˆæ—¶ï¼Œä½¿ç”¨ç›®æ ‡å®½åº¦sizeParamç¡®ä¿å¡«å……è¡Œå®½åº¦ä¸€è‡´
                    const emptyLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
                    
                    // ç”¨ç©ºè¡Œå¡«å……åˆ°æœ€å¤§è¡Œæ•°
                    while (normalized.length < maxLines) {
                        normalized.push(emptyLine);
                    }
                    
                    return normalized;
                });
                
                const finalLines = [];
                
                // é€è¡Œæ‹¼æ¥
                for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
                    let combinedLine = '';
                    
                    for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
                        combinedLine += normalizedResults[charIndex][lineIndex];
                        
                        // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œæ·»åŠ é—´è·åˆ—
                        if (charIndex < normalizedResults.length - 1 && spacing > 0) {
                            combinedLine += 'ğŸŒ‘'.repeat(spacing);
                        }
                    }
                    
                    finalLines.push(combinedLine);
                }
                
                return finalLines.join('\n');
            }
            
            // ç”Ÿæˆå¸¦å…ƒæ•°æ®çš„å•ä¸ªå­—ç¬¦
            generateSingleCharWithMeta(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
                if (!char.trim()) return [];
                
                const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
                
                // ç¬¬ä¸€é˜¶æ®µï¼šåˆ›å»ºè¶³å¤Ÿå¤§çš„canvasæ¥å®Œæ•´æ¸²æŸ“å­—ç¬¦
                const baseFontSize = Math.max(sizeParam * 5, 50);
                const canvasWidth = baseFontSize * 2;
                const canvasHeight = baseFontSize * 2;
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                const ctx = canvas.getContext('2d');
                
                // ç»˜åˆ¶ç™½è‰²èƒŒæ™¯
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶é»‘è‰²å­—ç¬¦
                ctx.fillStyle = 'black';
                ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const x = canvas.width / 2;
                const y = canvas.height / 2;
                ctx.fillText(char, x, y);
                
                console.log(`å­—ç¬¦ "${char}" æ¸²æŸ“: canvas=${canvasWidth}x${canvasHeight}, fontSize=${baseFontSize}`);
                
                // è·å–å›¾åƒæ•°æ®å¹¶è½¬æ¢ä¸ºåƒç´ çŸ©é˜µ
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixelMatrix = [];
                
                for (let y = 0; y < canvas.height; y++) {
                    pixelMatrix[y] = [];
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        const gray = 0.299 * imageData.data[idx] + 
                                   0.587 * imageData.data[idx + 1] + 
                                   0.114 * imageData.data[idx + 2];
                        pixelMatrix[y][x] = this.grayToColorLevel(gray);
                    }
                }
                
                // æ‰¾åˆ°å­—ç¬¦çš„å®é™…è¾¹ç•Œ
                let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
                let foundText = false;
                
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if (pixelMatrix[y][x] === 0) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            foundText = true;
                        }
                    }
                }
                
                if (!foundText) {
                    // å¦‚æœæ²¡æ‰¾åˆ°æ–‡å­—ï¼Œè¿”å›æŒ‰ç›®æ ‡å°ºå¯¸çš„é»˜è®¤çŸ©å½¢å…ƒæ•°æ®
                    const defaultSize = isVertical ? [sizeParam, 3] : [3, sizeParam];
                    const defaultGrid = [];
                    for (let row = 0; row < defaultSize[1]; row++) {
                        defaultGrid[row] = [];
                        for (let col = 0; col < defaultSize[0]; col++) {
                            defaultGrid[row][col] = this.gridToMoonWithMeta(Array(5).fill().map(() => Array(5).fill(0)));
                        }
                    }
                    return defaultGrid;
                }
                
                // ç¬¬äºŒé˜¶æ®µï¼šå°†å­—ç¬¦è¾¹ç•Œæ˜ å°„åˆ°ç›®æ ‡å°ºå¯¸
                const charWidth = maxX - minX + 1;
                const charHeight = maxY - minY + 1;
                
                let targetPixelWidth, targetPixelHeight;
                if (isVertical) {
                    targetPixelWidth = sizeParam * 5;
                    targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
                    targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
                } else {
                    targetPixelHeight = sizeParam * 5;
                    targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
                    targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
                }
                
                console.log(`å­—ç¬¦ "${char}" è¾¹ç•Œ: ${charWidth}x${charHeight} â†’ ç›®æ ‡: ${targetPixelWidth}x${targetPixelHeight}`);
                
                // ç¬¬ä¸‰é˜¶æ®µï¼šæŒ‰ç›®æ ‡å°ºå¯¸è¿›è¡Œ5x5ç½‘æ ¼æ‰«æå¹¶ç”Ÿæˆå…ƒæ•°æ®
                const gridSize = 5;
                const metaGrid = [];
                
                for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
                    const metaRow = [];
                    for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
                        // æå–5x5å­ç½‘æ ¼
                        const subGrid = [];
                        for (let dy = 0; dy < 5; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < 5; dx++) {
                                const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
                                const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
                                
                                if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
                                    subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
                                } else {
                                    subGrid[dy][dx] = 1; // ç™½è‰²
                                }
                            }
                        }
                        
                        metaRow.push(this.gridToMoonWithMeta(subGrid));
                    }
                    metaGrid.push(metaRow);
                }
                
                console.log(`å­—ç¬¦ "${char}" å…ƒæ•°æ®è¾“å‡º: ${metaGrid[0]?.length || 0}åˆ— x ${metaGrid.length}è¡Œ`);
                
                return metaGrid;
            }

            // ç”Ÿæˆæœˆæ–‡å­—ï¼ˆä½¿ç”¨å•å­—ç¬¦å¤„ç†æ¶æ„ï¼Œæ”¯æŒå‚ç›´åŒ–å¤„ç†ï¼‰
            generate(text, sizeParam = 20, fontType = 'custom', isVertical = true, reverseColor = false, spacing = 0, enableVerticalProcessing = true, showVerticalDebug = false) {
                if (!text.trim()) return '';
                
                console.log(`å•å­—ç¬¦å¤„ç†æ¶æ„: text="${text}", sizeParam=${sizeParam}, isVertical=${isVertical}, spacing=${spacing}`);
                console.log(`æ’ç‰ˆæ–¹å‘ç¡®è®¤: ${isVertical ? 'ç«–å‘æ’ç‰ˆï¼ˆå­—ç¬¦å‚ç›´æ’åˆ—ï¼‰' : 'æ¨ªå‘æ’ç‰ˆï¼ˆå­—ç¬¦æ°´å¹³æ’åˆ—ï¼‰'}`);
                console.log(`å‚ç›´åŒ–å¤„ç†: ${enableVerticalProcessing ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
                
                // å°†æ–‡æœ¬æ‹†åˆ†ä¸ºå­—ç¬¦æ•°ç»„
                const chars = Array.from(text);
                
                if (enableVerticalProcessing) {
                    // ä¸ºæ¯ä¸ªå­—ç¬¦ç”Ÿæˆå¸¦å…ƒæ•°æ®çš„ç»“æœ
                    const charMetaResults = chars.map(char => {
                        return this.generateSingleCharWithMeta(char, sizeParam, fontType, isVertical);
                    });
                    
                    // åˆ›å»ºå…¨å±€å…ƒæ•°æ®ç½‘æ ¼ç”¨äºå‚ç›´åŒ–å¤„ç†
                    let globalMetaGrid = [];
                    let maxCharWidth = 0;
                    
                    if (isVertical) {
                        // ç«–å‘æ’ç‰ˆï¼šå­—ç¬¦ä»ä¸Šåˆ°ä¸‹æ’åˆ—
                        for (let charIndex = 0; charIndex < charMetaResults.length; charIndex++) {
                            const charMeta = charMetaResults[charIndex];
                            maxCharWidth = Math.max(maxCharWidth, charMeta[0]?.length || 0);
                            
                            // æ·»åŠ å½“å‰å­—ç¬¦çš„æ‰€æœ‰è¡Œåˆ°å…¨å±€ç½‘æ ¼
                            globalMetaGrid.push(...charMeta);
                            
                            // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦ä¸”éœ€è¦é—´è·ï¼Œæ·»åŠ é—´è·è¡Œ
                            if (charIndex < charMetaResults.length - 1 && spacing > 0) {
                                for (let s = 0; s < spacing; s++) {
                                    const spacingRow = [];
                                    for (let col = 0; col < (charMeta[0]?.length || sizeParam); col++) {
                                        spacingRow.push({
                                            originalMoonPhase: 'ğŸŒ‘',
                                            finalMoonPhase: 'ğŸŒ‘',
                                            densityLevel: 'æä½å¯†åº¦',
                                            densitySymbol: 'â¬›',
                                            bias: 'balanced',
                                            blackCount: 0,
                                            centerX: 2
                                        });
                                    }
                                    globalMetaGrid.push(spacingRow);
                                }
                            }
                        }
                    } else {
                        // æ¨ªå‘æ’ç‰ˆï¼šå­—ç¬¦ä»å·¦åˆ°å³æ’åˆ—
                        const maxLines = Math.max(...charMetaResults.map(result => result.length));
                        
                        // æ ‡å‡†åŒ–æ‰€æœ‰å­—ç¬¦ç»“æœçš„è¡Œæ•°
                        const normalizedResults = charMetaResults.map(result => {
                            const normalized = [...result];
                            const charWidth = result[0]?.length || sizeParam;
                            
                            while (normalized.length < maxLines) {
                                const emptyRow = [];
                                for (let col = 0; col < charWidth; col++) {
                                    emptyRow.push({
                                        originalMoonPhase: 'ğŸŒ‘',
                                        finalMoonPhase: 'ğŸŒ‘',
                                        densityLevel: 'æä½å¯†åº¦',
                                        densitySymbol: 'â¬›',
                                        bias: 'balanced',
                                        blackCount: 0,
                                        centerX: 2
                                    });
                                }
                                normalized.push(emptyRow);
                            }
                            
                            return normalized;
                        });
                        
                        // é€è¡Œæ‹¼æ¥æ‰€æœ‰å­—ç¬¦
                        for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
                            const combinedRow = [];
                            
                            for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
                                combinedRow.push(...normalizedResults[charIndex][lineIndex]);
                                
                                // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªå­—ç¬¦ä¸”éœ€è¦é—´è·ï¼Œæ·»åŠ é—´è·åˆ—
                                if (charIndex < normalizedResults.length - 1 && spacing > 0) {
                                    for (let s = 0; s < spacing; s++) {
                                        combinedRow.push({
                                            originalMoonPhase: 'ğŸŒ‘',
                                            finalMoonPhase: 'ğŸŒ‘',
                                            densityLevel: 'æä½å¯†åº¦',
                                            densitySymbol: 'â¬›',
                                            bias: 'balanced',
                                            blackCount: 0,
                                            centerX: 2
                                        });
                                    }
                                }
                            }
                            
                            globalMetaGrid.push(combinedRow);
                        }
                    }
                    
                    console.log(`å…¨å±€ç½‘æ ¼åˆ›å»ºå®Œæˆ: ${globalMetaGrid[0]?.length || 0}åˆ— x ${globalMetaGrid.length}è¡Œ`);
                    
                    // åº”ç”¨å‚ç›´åŒ–å¤„ç†
                    const targetDensityLevels = [];
                    if (document.getElementById('verticalMedium').checked) {
                        targetDensityLevels.push('ä¸­ç­‰å¯†åº¦');
                    }
                    if (document.getElementById('verticalHigh').checked) {
                        targetDensityLevels.push('æ¬¡é«˜å¯†åº¦');
                    }
                    const thresholdN = 2; // é»˜è®¤é˜ˆå€¼
                    
                    globalMetaGrid = this.applyVerticalProcessing(globalMetaGrid, targetDensityLevels, thresholdN);
                    
                    // éªŒè¯å‚ç›´åŒ–å¤„ç†çš„ç»“æœ
                    console.error(`ğŸ” éªŒè¯å‚ç›´åŒ–å¤„ç†ç»“æœ:`);
                    let avoidCount = 0, keepCount = 0;
                    this.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < globalMetaGrid.length && pos.col < globalMetaGrid[pos.row].length) {
                            const cell = globalMetaGrid[pos.row][pos.col];
                            console.error(`éªŒè¯ä½ç½®(${pos.row},${pos.col}): finalMoonPhase=${cell.finalMoonPhase}, å¯†åº¦=${cell.densityLevel}`);
                            if (cell.finalMoonPhase === 'ğŸŒ‘') {
                                avoidCount++;
                            } else if (cell.finalMoonPhase === 'ğŸŒ•') {
                                keepCount++;
                            }
                        }
                    });
                    console.error(`ğŸ“Š å‚ç›´åŒ–å¤„ç†ç»Ÿè®¡: é¿è®©ğŸŒ‘=${avoidCount}ä¸ª, ä¿æŒğŸŒ•=${keepCount}ä¸ª`);
                    
                    // ä»å¤„ç†åçš„å…ƒæ•°æ®ç½‘æ ¼æå–æœ€ç»ˆæœˆç›¸
                    const resultLines = globalMetaGrid.map(row => 
                        row.map(cell => cell.finalMoonPhase).join('')
                    );
                    
                    let result = resultLines.join('\n');
                    
                    // å¦‚æœå¯ç”¨è°ƒè¯•æ¨¡å¼ï¼Œåº”ç”¨å‚ç›´åŒ–è°ƒè¯•ç¬¦å·
                    if (showVerticalDebug) {
                        result = this.applyVerticalDebugSymbols(result);
                        console.log(`å‚ç›´åŒ–è°ƒè¯•ç¬¦å·å·²åº”ç”¨ï¼Œå…±${this.verticalProcessingPositions.length}ä¸ªä½ç½®`);
                    }
                    
                    console.log(`å‚ç›´åŒ–å¤„ç†å®Œæˆï¼Œå­—ç¬¦æ•°: ${chars.length}, ç»“æœè¡Œæ•°: ${result.split('\n').length}`);
                    
                    return result;
                    
                } else {
                    // ä¼ ç»Ÿå¤„ç†æ–¹å¼ï¼ˆæ— å‚ç›´åŒ–ï¼‰
                    const charResults = chars.map(char => {
                        return this.generateSingleChar(char, sizeParam, fontType, isVertical);
                    });
                    
                    // æ ¹æ®æ’ç‰ˆæ–¹å‘æ‹¼æ¥ç»“æœ
                    let result;
                    if (isVertical) {
                        result = this.combineVertically(charResults, spacing, sizeParam);
                    } else {
                        result = this.combineHorizontally(charResults, spacing, sizeParam);
                    }
                    
                    console.log(`å•å­—ç¬¦ç”Ÿæˆå®Œæˆï¼Œå­—ç¬¦æ•°: ${chars.length}, ç»“æœè¡Œæ•°: ${result.split('\n').length}`);
                    return result;
                }
            }
        }
        
        // å­—ä½“æ˜ å°„
        const FONT_FAMILIES = {
            'default': 'sans-serif',
            'gothic': '"ãƒ¡ã‚¤ãƒªã‚ª", "Meiryo", "Hiragino Kaku Gothic ProN", "æ¸¸ã‚´ã‚·ãƒƒã‚¯", "Yu Gothic", "MS Pã‚´ã‚·ãƒƒã‚¯", "MS PGothic", sans-serif',
            'mincho': '"æ¸¸æ˜æœ", "Yu Mincho", "Hiragino Mincho ProN", "MS æ˜æœ", "MS Mincho", serif'
        };

        // å­—ä½“é¢„è®¾é…ç½®ï¼šç²˜åˆç³»æ•°
        const FONT_CONFIGS = {
            'default': { adhesionCoefficient: 2 },
            'gothic': { adhesionCoefficient: 2 },
            'mincho': { adhesionCoefficient: 3 }
        };
        
        // åˆå§‹åŒ–
        const generator = new SimpleMoonGenerator();
        const horizontalEnhancer = new HorizontalEnhancer();
        
        // æ›´æ–°æ»‘å—æ ‡ç­¾çš„å‡½æ•°
        function updateSliderLabel() {
            const isVertical = document.querySelector('input[name="textDirection"]:checked').value === 'vertical';
            const sliderLabel = document.getElementById('sliderLabel');
            const sliderUnit = document.getElementById('sliderUnit');
            
            if (isVertical) {
                sliderLabel.textContent = 'å¹…æ–‡å­—æ•°';
                sliderUnit.textContent = 'æ–‡å­—';
            } else {
                sliderLabel.textContent = 'é«˜ã•';
                sliderUnit.textContent = 'è¡Œ';
            }
        }
        
        // å¤åˆ¶åŠŸèƒ½
        function copyToClipboard() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
            
            navigator.clipboard.writeText(moonArt).then(() => {
                const copyBtn = document.getElementById('copyBtn');
                const btnText = copyBtn.querySelector('.btn-text');
                const originalText = btnText.textContent;
                
                btnText.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼';
                copyBtn.classList.add('success');
                
                setTimeout(() => {
                    btnText.textContent = originalText;
                    copyBtn.classList.remove('success');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }
        
        // æ–‡æœ¬ä¸‹è½½åŠŸèƒ½
        function downloadText() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
            
            const randomId = Math.random().toString(36).substring(2, 8);
            const filename = `moon-art-${randomId}-${Date.now()}.txt`;
            
            const blob = new Blob([moonArt], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        // å›¾ç‰‡ä¸‹è½½åŠŸèƒ½
        function downloadImage() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
            
            // åˆ›å»ºç”»å¸ƒ
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const lines = moonArt.split('\n');
            const fontSize = 20;
            const lineHeight = fontSize;
            
            // è®¡ç®—ç”»å¸ƒå°ºå¯¸
            canvas.width = lines[0].length * fontSize / 2;
            canvas.height = lines.length * lineHeight;
            
            // ç»˜åˆ¶æœˆäº®è‰ºæœ¯ï¼ˆé€æ˜èƒŒæ™¯ï¼‰
            ctx.fillStyle = 'black';
            ctx.font = `${fontSize}px sans-serif`;
            ctx.textBaseline = 'top';
            
            lines.forEach((line, lineIndex) => {
                let x = 0;
                for (let i = 0; i < line.length; i += 2) {
                    const emoji = line.substr(i, 2);
                    ctx.fillText(emoji, x, lineIndex * lineHeight);
                    x += fontSize;
                }
            });
            
            // ä¸‹è½½å›¾ç‰‡
            const randomId = Math.random().toString(36).substring(2, 8);
            const filename = `moon-art-${randomId}-${Date.now()}.png`;
            
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
        
        function updatePreview() {
            const text = document.getElementById('textInput').value.trim();
            const sizeValue = parseInt(document.getElementById('heightSlider').value);
            const fontType = document.getElementById('fontSelect').value;
            const adhesionCoefficient = parseInt(document.getElementById('adhesionSlider').value);
            const spacing = parseInt(document.getElementById('spacingSlider').value);
            
            const selectedRadio = document.querySelector('input[name="textDirection"]:checked');
            console.log('updatePreview - é€‰ä¸­çš„radioæŒ‰é’®:', selectedRadio);
            console.log('updatePreview - é€‰ä¸­çš„å€¼:', selectedRadio?.value);
            const isVertical = selectedRadio?.value === 'vertical';
            console.log('updatePreview - æœ€ç»ˆisVerticalå€¼:', isVertical);
            
            const reverseColor = document.getElementById('reverseColor').checked;
            const showVerticalInfo = document.getElementById('showVerticalInfo').checked;
            const enableDenoising = document.getElementById('enableDenoising').checked;
            
            if (!text) {
                document.getElementById('moonArt').textContent = '<!-- å…¥åŠ›ã—ã¦ãã ã•ã„ -->';
                document.getElementById('actionButtons').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            
            try {
                // ç”ŸæˆåŸºç¡€ç»“æœï¼ˆå¯ç”¨å‚ç›´åŒ–å¤„ç†ï¼Œä¸æ‰§è¡Œåè‰²ï¼‰
                let result = generator.generate(text, sizeValue, fontType, isVertical, false, spacing, true, false); // å…ˆä¸æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                
                // æ·»åŠ å‚ç›´åŒ–å¤„ç†åçš„è°ƒè¯•è¾“å‡º
                console.log(`ğŸ”„ å‚ç›´åŒ–å¤„ç†å®Œæˆï¼Œå‡†å¤‡è¿›è¡Œæ¨ªå‘åŠ å¼ºç®—æ³•`);
                console.log(`å‚ç›´åŒ–å¤„ç†è®°å½•æ•°: ${generator.verticalProcessingPositions.length}`);
                if (generator.verticalProcessingPositions.length > 0) {
                    console.log(`å‚ç›´åŒ–å¤„ç†è¯¦æƒ…:`, generator.verticalProcessingPositions);
                    const lines = result.split('\n');
                    generator.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < lines.length && pos.col < lines[pos.row].length) {
                            const char = Array.from(lines[pos.row])[pos.col];
                            console.log(`ä½ç½®(${pos.row},${pos.col}): å½“å‰å­—ç¬¦=${char}, å¯†åº¦=${pos.densityLevel}`);
                        }
                    });
                }
                
                // åº”ç”¨æ¨ªå‘åŠ å¼ºç®—æ³•
                horizontalEnhancer.setAdhesionCoefficient(adhesionCoefficient);
                horizontalEnhancer.setEnableDenoising(enableDenoising);
                result = horizontalEnhancer.enhance(result);
                
                // å¦‚æœå¯ç”¨å‚ç›´åŒ–è°ƒè¯•ä¿¡æ¯ï¼Œåœ¨æ¨ªå‘åŠ å¼ºç®—æ³•ä¹‹åæ˜¾ç¤º
                if (showVerticalInfo) {
                    result = generator.applyVerticalDebugSymbols(result);
                    console.log(`å‚ç›´åŒ–è°ƒè¯•ç¬¦å·å·²åº”ç”¨ï¼ˆæ¨ªå‘åŠ å¼ºåï¼‰ï¼Œå…±${generator.verticalProcessingPositions.length}ä¸ªä½ç½®`);
                }
                
                // å‚ç›´åŒ–å¤„ç†çš„æœ€ç»ˆç»“æœæ£€æŸ¥
                console.log(`ğŸ” å‚ç›´åŒ–å¤„ç†æœ€ç»ˆç»“æœæ£€æŸ¥ï¼ˆæ— æ¨ªå‘å¹²æ‰°ï¼‰`);
                if (generator.verticalProcessingPositions.length > 0) {
                    const linesFinal = result.split('\n');
                    let moon_count = 0, black_count = 0;
                    
                    generator.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < linesFinal.length && pos.col < linesFinal[pos.row].length) {
                            const charFinal = Array.from(linesFinal[pos.row])[pos.col];
                            console.log(`æœ€ç»ˆä½ç½®(${pos.row},${pos.col}): å­—ç¬¦=${charFinal}, å¯†åº¦=${pos.densityLevel}`);
                            
                            if (charFinal === 'ğŸŒ•') moon_count++;
                            else if (charFinal === 'ğŸŒ‘') black_count++;
                        }
                    });
                    
                    console.error(`ğŸ“Š å‚ç›´åŒ–å¤„ç†ç»Ÿè®¡: ğŸŒ•=${moon_count}ä¸ª, ğŸŒ‘=${black_count}ä¸ª`);
                    
                    // æ£€æŸ¥æ•´ä¸ªç»“æœå­—ç¬¦ä¸²çš„å†…å®¹ç»Ÿè®¡
                    const allChars = result.replace(/\n/g, '');
                    const totalMoon = (allChars.match(/ğŸŒ•/g) || []).length;
                    const totalBlack = (allChars.match(/ğŸŒ‘/g) || []).length;
                    console.error(`ğŸ“Š æ•´ä½“å­—ç¬¦ç»Ÿè®¡: æ€»ğŸŒ•=${totalMoon}ä¸ª, æ€»ğŸŒ‘=${totalBlack}ä¸ª`);
                }
                
                // æœ€åæ‰§è¡Œåè‰²æ“ä½œ
                if (reverseColor) {
                    result = Array.from(result).map(char => {
                        if (char === '\n') return char;
                        return generator.reverseMoon(char);
                    }).join('');
                }
                
                document.getElementById('moonArt').textContent = result;
                
                // æ˜¾ç¤ºå‚ç›´åŒ–å¤„ç†è°ƒè¯•ä¿¡æ¯
                document.getElementById('debugInfo').style.display = 'block';
                const isVerticalEnabled = targetDensityLevels.length > 0;
                document.getElementById('verticalProcessingStatus').textContent = isVerticalEnabled ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹';
                document.getElementById('targetDensityLevels').textContent = targetDensityLevels.length > 0 ? targetDensityLevels.join('ã€') : 'ãªã—';
                document.getElementById('thresholdN').textContent = '2';
                document.getElementById('processingMode').textContent = targetDensityLevels.length > 0 ? targetDensityLevels.join('ãƒ»') + 'ï¼ˆãƒãƒ©ãƒ³ã‚¹é‡å¿ƒã®ã¿ï¼‰' : 'ãªã—';
                
                // æ˜¾ç¤ºæ“ä½œæŒ‰é’®
                document.getElementById('actionButtons').style.display = 'flex';
                
                    
            } catch (error) {
                console.error('Generation error:', error);
                document.getElementById('moonArt').textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
                document.getElementById('actionButtons').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
            }
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                   window.innerWidth <= 768;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const heightSlider = document.getElementById('heightSlider');
            const heightValue = document.getElementById('heightValue');
            const adhesionSlider = document.getElementById('adhesionSlider');
            const adhesionValue = document.getElementById('adhesionValue');
            const spacingSlider = document.getElementById('spacingSlider');
            const spacingValue = document.getElementById('spacingValue');
            
            heightSlider.addEventListener('input', () => {
                heightValue.textContent = heightSlider.value;
                updatePreview();
            });
            
            adhesionSlider.addEventListener('input', () => {
                adhesionValue.textContent = adhesionSlider.value;
                updatePreview();
            });
            
            spacingSlider.addEventListener('input', () => {
                spacingValue.textContent = spacingSlider.value;
                updatePreview();
            });
            
            document.getElementById('textInput').addEventListener('input', updatePreview);
            document.getElementById('fontSelect').addEventListener('change', (e) => {
                // åˆ‡æ¢å­—ä½“æ—¶è‡ªåŠ¨åº”ç”¨é¢„è®¾é…ç½®
                const fontType = e.target.value;
                const config = FONT_CONFIGS[fontType] || FONT_CONFIGS['default'];
                
                adhesionSlider.value = config.adhesionCoefficient;
                adhesionValue.textContent = config.adhesionCoefficient;
                
                updatePreview();
            });
            document.getElementById('showDebugCanvas').addEventListener('change', updatePreview);
            
            // æ·»åŠ æ–¹å‘é€‰æ‹©äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('input[name="textDirection"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    updateSliderLabel(); // æ›´æ–°æ ‡ç­¾
                    updatePreview(); // é‡æ–°ç”Ÿæˆ
                });
            });
            
            // æ·»åŠ åè‰²å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('reverseColor').addEventListener('change', updatePreview);
            
            // æ·»åŠ å‚ç›´åŒ–ä¿¡æ¯å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('showVerticalInfo').addEventListener('change', updatePreview);
            
            // æ·»åŠ å‚ç›´åŒ–å¤„ç†æ§åˆ¶å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('verticalMedium').addEventListener('change', updatePreview);
            document.getElementById('verticalHigh').addEventListener('change', updatePreview);
            
            // æ·»åŠ å»å™ªå¤„ç†æ§åˆ¶å¤é€‰æ¡†äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('enableDenoising').addEventListener('change', updatePreview);
            
            // æ·»åŠ æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('downloadTextBtn').addEventListener('click', downloadText);
            document.getElementById('downloadImageBtn').addEventListener('click', downloadImage);
            
            // ä»…åœ¨æ¡Œé¢è®¾å¤‡ä¸Šæ·»åŠ æ”¶è—æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            if (!isMobileDevice()) {
                document.getElementById('bookmarkBtn').addEventListener('click', addBookmark);
            } else {
                // ç§»åŠ¨è®¾å¤‡ä¸Šå®Œå…¨éšè—æŒ‰é’®
                const bookmarkBtn = document.getElementById('bookmarkBtn');
                if (bookmarkBtn) {
                    bookmarkBtn.style.display = 'none';
                }
            }
            
            // æ ¹æ®è®¾å¤‡ç±»å‹è®¾ç½®é»˜è®¤æ–¹å‘ï¼ˆä»…åœ¨æ²¡æœ‰é€‰æ‹©æ—¶ï¼‰
            const currentSelection = document.querySelector('input[name="textDirection"]:checked');
            if (!currentSelection) {
                if (isMobileDevice()) {
                    document.querySelector('input[name="textDirection"][value="vertical"]').checked = true;
                } else {
                    document.querySelector('input[name="textDirection"][value="horizontal"]').checked = true;
                }
                // è®¾ç½®é»˜è®¤å€¼åï¼Œæ›´æ–°æ ‡ç­¾å’Œé¢„è§ˆ
                updateSliderLabel();
            }
            
            // åˆå§‹åŒ–å­—ä½“é¢„è®¾é…ç½®
            const defaultFontType = document.getElementById('fontSelect').value;
            const defaultConfig = FONT_CONFIGS[defaultFontType] || FONT_CONFIGS['default'];
            adhesionSlider.value = defaultConfig.adhesionCoefficient;
            adhesionValue.textContent = defaultConfig.adhesionCoefficient;
            
            // åˆå§‹åŒ–æ ‡ç­¾å’Œç”Ÿæˆï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿DOMçŠ¶æ€æ›´æ–°ï¼‰
            setTimeout(() => {
                updateSliderLabel();
                updatePreview();
            }, 0);
            
            // è®¾ç½®é¡µè„šæ”¶è—æŒ‰é’®
            setupFooterBookmark();
        });
        
        // æ”¶è—åŠŸèƒ½
        function addBookmark() {
            const title = 'æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ - MojiMoon';
            const url = 'https://mojimoon.com';
            
            try {
                // ç°ä»£æµè§ˆå™¨çš„å¤„ç†
                if (navigator.userAgent.indexOf('Chrome') > -1 || navigator.userAgent.indexOf('Safari') > -1) {
                    // Chrome/Safari: æ˜¾ç¤ºå‹å¥½çš„æç¤º
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const shortcut = isMac ? 'Cmd+D' : 'Ctrl+D';
                    alert(`${shortcut} ã‚’æŠ¼ã—ã¦ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¦ãã ã•ã„ğŸŒ™`);
                } else if (window.sidebar && window.sidebar.addPanel) {
                    // Firefox
                    window.sidebar.addPanel(title, url, '');
                } else if (window.external && window.external.AddFavorite) {
                    // Internet Explorer
                    window.external.AddFavorite(url, title);
                } else {
                    // å…¶ä»–æµè§ˆå™¨
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const shortcut = isMac ? 'Cmd+D' : 'Ctrl+D';
                    alert(`${shortcut} ã‚’æŠ¼ã—ã¦ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¦ãã ã•ã„`);
                }
            } catch (error) {
                console.error('Bookmark error:', error);
                alert('ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã™ã‚‹ã«ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ“ä½œã—ã¦ãã ã•ã„ã€‚');
            }
        }
        
        // ãƒ•ãƒƒã‚¿ãƒ¼åè—æŒ‰é’®äº‹ä»¶
        function setupFooterBookmark() {
            const footerBookmarkBtn = document.getElementById('footerBookmarkBtn');
            if (footerBookmarkBtn && !isMobileDevice()) {
                footerBookmarkBtn.addEventListener('click', addBookmark);
            } else if (footerBookmarkBtn) {
                // ç§»åŠ¨è®¾å¤‡ä¸Šéšè—footterä¸­çš„æ”¶è—æŒ‰é’®
                footerBookmarkBtn.style.display = 'none';
            }
        }
    </script>
    
    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <h2 style="text-align: center; margin-bottom: 15px; font-size: 1.2rem; font-weight: 600; color: #374151;">ã“ã®ã‚µã‚¤ãƒˆãŒæ°—ã«å…¥ã£ãŸã‚‰ã€ãœã²<button id="footerBookmarkBtn" class="footer-bookmark-btn" title="ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ">ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯</button>ã—ã¦ãã ã•ã„</h2>
        </div>
    </footer>
</body>
</html>