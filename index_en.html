<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Moon Emoji Art Generator | Free Text Converter</title>
<meta name="description" content="Free online tool to convert text and images into beautiful moon emoji art. Supports vertical and horizontal layouts, multiple fonts. Create unique ASCII art using moon phases!">
<meta name="keywords" content="moon characters,emoji art,text art,generator,free tool,moon phases,ASCII art">
<meta name="author" content="Moon Character Generator">
<meta name="robots" content="index,follow">
<meta property="og:title" content="Moon Character Generator">
<meta property="og:description" content="Convert text to moon emoji art - Free online tool">
<meta property="og:type" content="website">
<meta property="og:url" content="https://mojimoon.com/index_en.html">
<meta property="og:image" content="https://mojimoon.com/moon_icon.png">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@mojimoon">
<meta name="twitter:title" content="Moon Character Generator">
<meta name="twitter:description" content="Convert text to moon emoji art">
<meta name="twitter:image" content="https://mojimoon.com/moon_icon.png">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ™</text></svg>">
<link rel="icon" type="image/png" sizes="32x32" href="/moon_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/moon_icon.png">
<link rel="apple-touch-icon" href="/moon_icon.png">
<link rel="canonical" href="https://mojimoon.com/index_en.html">
<link rel="alternate" href="https://mojimoon.com/" hreflang="ja">
<link rel="alternate" href="https://mojimoon.com/index_en.html" hreflang="en">
<script type="application/ld+json">
{
"@context": "https://schema.org",
"@type": "WebApplication",
"name": "Moon Character Generator",
"description": "Convert text to moon emoji art",
"applicationCategory": "UtilityApplication",
"operatingSystem": "All",
"inLanguage": "en",
"isAccessibleForFree": true
}
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WD9XP5ERGX"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WD9XP5ERGX');
</script>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
color: white;
padding: 20px;
}
.container {
max-width: 800px;
margin: 0 auto;
}
.header {
text-align: center;
margin-bottom: 20px;
position: relative;
}
.guide-link {
display: inline-block;
margin-top: 10px;
padding: 8px 16px;
background: rgba(255, 255, 255, 0.1);
color: white;
text-decoration: none;
border-radius: 20px;
font-size: 14px;
font-weight: 500;
border: 1px solid rgba(255, 255, 255, 0.2);
transition: all 0.2s ease;
backdrop-filter: blur(10px);
margin-right: 10px;
}
.guide-link:hover {
background: rgba(255, 255, 255, 0.2);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.lang-switcher {
display: inline-block;
margin-top: 10px;
padding: 8px 16px;
background: rgba(255, 255, 255, 0.1);
color: white;
text-decoration: none;
border-radius: 20px;
font-size: 14px;
font-weight: 500;
border: 1px solid rgba(255, 255, 255, 0.2);
transition: all 0.2s ease;
backdrop-filter: blur(10px);
}
.lang-switcher:hover {
background: rgba(255, 255, 255, 0.2);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.control-panel {
background: rgba(255, 255, 255, 0.1);
border-radius: 15px;
padding: 18px;
margin-bottom: 15px;
backdrop-filter: blur(10px);
}
.form-group {
margin-bottom: 8px;
}
.form-group .height-control {
width: 95%;
margin-left: 0;
}
.form-group label {
display: block;
margin-bottom: 5px;
font-weight: 600;
}
.form-group h3 {
margin-bottom: 5px;
}
.height-control-group {
margin-bottom: 12px;
}
.text-input {
width: 95%;
height: 48px;
padding: 12px;
border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 8px;
background: rgba(255, 255, 255, 0.1);
color: white;
font-size: 16px;
margin: 0 auto;
display: block;
}
.text-input::placeholder {
color: rgba(255, 255, 255, 0.6);
}
.height-control {
display: flex;
align-items: center;
gap: 8px;
}
.dual-control-group .height-control {
width: 100%;
max-width: 100%;
}
.dual-control-group .height-slider {
flex: 1;
min-width: 0;
}
.height-slider {
flex: 1;
height: 6px;
background: rgba(255, 255, 255, 0.2);
border-radius: 3px;
outline: none;
-webkit-appearance: none;
}
.height-slider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 20px;
height: 20px;
background: #8b5cf6;
border-radius: 50%;
cursor: pointer;
}
.form-group h3 span,
.control-item h3 span {
color: #fbbf24;
font-weight: 600;
}
.dual-control-group {
display: grid;
grid-template-columns: 50% 50%;
gap: 0;
margin-bottom: 12px;
width: 100%;
max-width: 100%;
box-sizing: border-box;
}
.dual-control-group .control-item {
width: 100%;
box-sizing: border-box;
}
.dual-control-group .control-item > h3,
.dual-control-group .control-item > .height-control {
width: 90%;
margin-left: 0;
}
.control-item h3 {
font-size: 1rem;
margin-bottom: 8px;
color: white;
font-weight: 600;
}
.input-tabs {
display: flex;
margin-bottom: 20px;
border-radius: 8px;
overflow: hidden;
background: rgba(255, 255, 255, 0.1);
}
.tab-button {
flex: 1;
padding: 12px 20px;
border: none;
background: transparent;
color: rgba(255, 255, 255, 0.7);
font-weight: 500;
cursor: pointer;
transition: all 0.2s ease;
}
.tab-button.active {
background: rgba(255, 255, 255, 0.2);
color: white;
}
.tab-content {
display: none;
}
.tab-content.active {
display: block;
}
.upload-area {
border: 2px dashed rgba(255, 255, 255, 0.3);
border-radius: 12px;
padding: 40px 20px;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
}
.upload-area:hover {
border-color: rgba(255, 255, 255, 0.5);
background: rgba(255, 255, 255, 0.05);
}
.upload-area.drag-over {
border-color: #8b5cf6;
background: rgba(139, 92, 246, 0.1);
}
.radio-group {
display: flex;
gap: 12px;
align-items: center;
}
.radio-option {
display: flex;
align-items: center;
gap: 8px;
cursor: pointer;
padding: 8px 12px;
border-radius: 6px;
transition: background 0.2s ease;
}
.radio-option:hover {
background: rgba(255, 255, 255, 0.1);
}
.radio-option input[type="radio"] {
width: 18px;
height: 18px;
accent-color: #8b5cf6;
}
.radio-option input[type="checkbox"] {
width: 18px;
height: 18px;
accent-color: #8b5cf6;
}
.radio-label {
font-weight: 500;
font-size: 0.9rem;
user-select: none;
}
.generate-btn {
width: 100%;
padding: 15px;
border: none;
border-radius: 10px;
background: linear-gradient(135deg, #8b5cf6, #7c3aed);
color: white;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
}
.generate-btn:hover {
background: linear-gradient(135deg, #7c3aed, #6d28d9);
transform: translateY(-1px);
}
.generate-btn:disabled {
background: rgba(255, 255, 255, 0.2);
cursor: not-allowed;
transform: none;
}
.moon-art {
font-family: monospace;
line-height: 1.4;
letter-spacing: 0.1em;
white-space: pre;
width: fit-content;
color: #fff;
padding-top: 5px;
}
.action-buttons {
display: flex;
gap: 10px;
margin-top: 15px;
flex-wrap: wrap;
}
.action-btn {
display: flex;
align-items: center;
gap: 8px;
padding: 10px 15px;
border: none;
border-radius: 8px;
font-size: 14px;
font-weight: 500;
cursor: pointer;
transition: all 0.2s ease;
color: white;
flex: 1;
min-width: 140px;
}
.copy-btn {
background: linear-gradient(135deg, #10b981, #059669);
}
.copy-btn:hover {
background: linear-gradient(135deg, #059669, #047857);
transform: translateY(-1px);
}
.download-btn {
background: linear-gradient(135deg, #3b82f6, #1d4ed8);
}
.download-btn:hover {
background: linear-gradient(135deg, #1d4ed8, #1e40af);
transform: translateY(-1px);
}
.hidden {
display: none !important;
}
.file-input {
display: none;
}
.upload-text {
font-size: 16px;
margin-bottom: 8px;
}
.upload-hint {
font-size: 14px;
color: rgba(255, 255, 255, 0.6);
}
.preview-panel {
background: rgba(255, 255, 255, 0.1);
border-radius: 15px;
padding: 20px;
backdrop-filter: blur(10px);
width: 100%;
max-width: 100%;
overflow-x: auto;
}
@media (max-width: 768px) {
.header {
margin-bottom: 15px;
}
.header h1 {
font-size: 1.5rem;
margin-bottom: 5px;
}
.guide-link {
font-size: 13px;
padding: 6px 12px;
}
.lang-switcher {
font-size: 13px;
padding: 6px 12px;
}
.control-panel {
padding: 12px;
margin-bottom: 12px;
}
.form-group {
margin-bottom: 4px;
}
.form-group h3 {
font-size: 1.1rem;
margin-bottom: 3px;
}
.radio-group {
gap: 8px;
}
.action-buttons {
gap: 5px;
flex-wrap: nowrap;
}
.action-btn {
min-width: 0;
padding: 8px 6px;
font-size: 12px;
flex: 1;
}
.upload-area {
padding: 30px 15px;
}
.height-control {
gap: 6px;
}
.noise-reduction-option {
display: none !important;
}
.height-control-group {
margin-bottom: 6px;
}
.dual-control-group {
grid-template-columns: 50% 50%;
gap: 0;
width: 100%;
max-width: 100%;
}
.dual-control-group .control-item {
width: 100%;
}
.dual-control-group .control-item > h3,
.dual-control-group .control-item > .height-control {
width: 95%;
}
}
.debug-section {
display: none !important;
}
.debug-header {
background: rgba(255, 193, 7, 0.2);
border: 1px solid rgba(255, 193, 7, 0.3);
border-radius: 8px;
padding: 12px 15px;
margin-bottom: 15px;
backdrop-filter: blur(5px);
color: #fbbf24;
font-weight: 500;
transition: all 0.2s ease;
}
.debug-header:hover {
background: rgba(255, 193, 7, 0.25);
border-color: rgba(255, 193, 7, 0.4);
}
.debug-content {
background: rgba(0, 0, 0, 0.2);
border-radius: 6px;
padding: 15px;
margin-top: 10px;
display: none;
}
.debug-content.expanded {
display: block;
}
.debug-controls {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 15px;
margin-bottom: 15px;
}
.debug-control {
display: flex;
flex-direction: column;
gap: 5px;
}
.debug-control label {
font-size: 12px;
color: #fbbf24;
font-weight: 500;
}
.debug-control input, .debug-control select {
padding: 6px 8px;
border-radius: 4px;
border: 1px solid rgba(255, 255, 255, 0.3);
background: rgba(255, 255, 255, 0.1);
color: white;
font-size: 12px;
}
.debug-info {
background: rgba(0, 0, 0, 0.3);
border-radius: 6px;
padding: 10px;
font-family: monospace;
font-size: 11px;
color: #fbbf24;
margin-bottom: 10px;
}
.label-style{font-weight:600;margin-bottom:8px;display:block}
.hidden{display:none}
.flex-center{display:flex;align-items:center;gap:8px}
.btn-footer{display:inline-block;padding:12px 24px;color:white;text-decoration:none;border-radius:8px;font-size:1rem;transition:transform 0.2s,box-shadow 0.2s;margin:5px}
.btn-cyan{background:linear-gradient(135deg,#06B6D4,#0891B2)}
.btn-green{background:linear-gradient(135deg,#10b981,#059669)}
.btn-blue{background:linear-gradient(135deg,#3b82f6,#1d4ed8)}
.friend-link{color:#6b7280;text-decoration:none;margin:0 8px}
</style>
</head>
<body>
<button id="favoriteBtn" class="favorite-btn" style="
position: fixed;
top: 20px;
right: 20px;
z-index: 1000;
padding: 8px 12px;
background: rgba(255, 255, 255, 0.1);
color: white;
border: 1px solid rgba(255, 255, 255, 0.2);
border-radius: 20px;
font-size: 14px;
cursor: pointer;
backdrop-filter: blur(10px);
transition: all 0.2s ease;
display: none;
">
â­ Favorite
</button>
<div class="container">
<header class="header">
<h1>ğŸŒ™ Moon Character Generator</h1>
<a href="guide_en.html" class="guide-link">ğŸ“– User Guide</a>
<a href="https://mojimoon.com/" class="lang-switcher">ğŸŒ æ—¥æœ¬èª</a>
</header>
<div class="control-panel">
<div class="input-tabs">
<button class="tab-button active" data-tab="text">Text Input</button>
<button class="tab-button" data-tab="image">Image Input</button>
</div>
<div class="tab-content active" id="textTab">
<div class="form-group">
<label for="textInput">Text Input</label>
<input type="text" id="textInput" class="text-input" placeholder="Enter text to convert..." maxlength="50">
</div>
<div class="form-group height-control-group">
<h3>Height: <span id="heightValue">10</span> rows</h3>
<div class="height-control">
<span>10</span>
<input type="range" id="heightSlider" class="height-slider" min="10" max="60" value="10">
<span>60</span>
</div>
</div>
<div class="form-group">
<h3>Font Style</h3>
<div class="radio-group">
<label class="radio-option">
<input type="radio" name="fontType" value="monospace" checked>
<span class="radio-label">Monospace</span>
</label>
<label class="radio-option">
<input type="radio" name="fontType" value="sans-serif">
<span class="radio-label">Sans-serif</span>
</label>
<label class="radio-option">
<input type="radio" name="fontType" value="serif">
<span class="radio-label">Serif</span>
</label>
</div>
</div>
<div class="form-group">
<h3>Text Direction</h3>
<div class="radio-group">
<label class="radio-option">
<input type="radio" name="direction" value="vertical">
<span class="radio-label">Vertical</span>
</label>
<label class="radio-option">
<input type="radio" name="direction" value="horizontal">
<span class="radio-label">Horizontal</span>
</label>
</div>
</div>
<div class="dual-control-group">
<div class="control-item">
<h3>Spacing: <span id="spacingValue">2</span></h3>
<div class="height-control">
<span>0</span>
<input type="range" id="spacingSlider" class="height-slider" min="0" max="10" value="2">
<span>10</span>
</div>
</div>
<div class="control-item">
<h3>Padding: <span id="paddingValue">0</span></h3>
<div class="height-control">
<span>0</span>
<input type="range" id="paddingSlider" class="height-slider" min="0" max="10" value="0">
<span>10</span>
</div>
</div>
</div>
<div class="form-group">
<div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
<input type="checkbox" id="reverseColor" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
<label for="reverseColor" style="cursor: pointer; font-weight: 600;">Reverse Color</label>
</div>
</div>
</div>
<div class="tab-content" id="imageTab">
<div class="form-group">
<label>Image Upload</label>
<div class="upload-area" id="uploadArea">
<div class="upload-text">ğŸ“ Click to select image or drag and drop</div>
<div class="upload-hint">Supports JPG, PNG, GIF formats</div>
</div>
<input type="file" id="imageInput" class="file-input" accept="image/*">
</div>
<div class="form-group height-control-group">
<h3>Height: <span id="imageHeightValue">60</span> rows</h3>
<div class="height-control">
<span>10</span>
<input type="range" id="imageHeightSlider" class="height-slider" min="10" max="500" value="60">
<span>500</span>
</div>
</div>
<div class="form-group height-control-group">
<h3>Padding: <span id="imagePaddingValue">0</span></h3>
<div class="height-control">
<span>0</span>
<input type="range" id="imagePaddingSlider" class="height-slider" min="0" max="10" value="0">
<span>10</span>
</div>
</div>
<div class="form-group">
<div style="display: flex; gap: 20px;">
<div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
<input type="checkbox" id="imageReverseColor" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
<label for="imageReverseColor" style="cursor: pointer; font-weight: 600;">Reverse Color</label>
</div>
<div class="noise-reduction-option" style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
<input type="checkbox" id="enableDenoising" checked style="width: 18px; height: 18px; accent-color: #8b5cf6;">
<label for="enableDenoising" style="cursor: pointer; font-weight: 600;">Noise Reduction</label>
</div>
</div>
</div>
</div>
<div id="actionButtons" class="action-buttons" style="display: none;">
<button id="copyBtn" class="action-btn copy-btn">
<span class="btn-icon">ğŸ“‹</span>
<span class="btn-text">Copy</span>
</button>
<button id="downloadTextBtn" class="action-btn download-btn">
<span class="btn-icon">ğŸ“„</span>
<span class="btn-text">Download Text</span>
</button>
<button id="downloadImageBtn" class="action-btn download-btn">
<span class="btn-icon">ğŸ–¼ï¸</span>
<span class="btn-text">Download Image</span>
</button>
</div>
</div>
</div>
<div class="container">
<div class="preview-panel">
<h2 style="margin-bottom: 8px; font-size: 12px; font-weight: 600;">Preview</h2>
<div id="debugInfo" style="margin-bottom: 10px; font-size: 11px; color: #fbbf24; font-family: monospace; display: none !important;">
<div>Vertical Processing: <span id="verticalProcessingStatus">Enabled</span></div>
<div>Target Density Levels: <span id="targetDensityLevels">Medium Density</span></div>
<div>Threshold n: <span id="thresholdN">2</span></div>
<div>Processing Mode: <span id="processingMode">Medium Density (Balance Center Only)</span></div>
</div>
<div id="moonArt" class="moon-art"></div>
<div style="margin-top: 20px; display: none;">
<label>
<input type="checkbox" id="showDebugCanvas"> Show Original Canvas Debug
</label>
</div>
<canvas id="debugCanvas" style="border: 1px solid #666; margin-top: 10px; background: white; display: none; max-width: 100%;"></canvas>
</div>
</div>
<script>
function isMobileDevice() {
return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
(navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
window.innerWidth <= 768;
}
let currentInputMode = 'text'; // 'text' or 'image'
let lastUploadedImageSrc = null; // Save last uploaded image data
let textModeSettings = {
height: 10,
padding: 0
};
let imageModeSettings = {
height: 60,
padding: 0
};
const COLOR_LEVELS = {
BLACK: 0,
WHITE: 1
};
class ImageProcessor {
constructor() {
this.threshold = 128; // äºŒå€¼åŒ–é˜ˆå€¼
this.bayerMatrix5x5 = [
[ 0, 12,  3, 15,  8],
[18,  6, 21,  9, 24],
[ 4, 16,  1, 13,  5],
[22, 10, 19,  7, 23],
[ 2, 14, 11, 20, 17]
];
}
async loadAndProcessImage(imageSrc, targetHeight, useGrayScale = false) {
return new Promise((resolve, reject) => {
const img = new Image();
img.onload = () => {
try {
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const aspectRatio = img.width / img.height;
const targetPixelHeight = targetHeight * 5; // 5x5ç³»ç»Ÿ
const targetPixelWidth = Math.round(targetPixelHeight * aspectRatio);
const finalHeight = Math.ceil(targetPixelHeight / 5) * 5;
const finalWidth = Math.ceil(targetPixelWidth / 5) * 5;
canvas.width = finalWidth;
canvas.height = finalHeight;
ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
const imageData = ctx.getImageData(0, 0, finalWidth, finalHeight);
const processedMatrix = useGrayScale 
? this.applyOrderedDithering(imageData)
: this.binarizeImage(imageData);
resolve({
matrix: processedMatrix,
width: finalWidth,
height: finalHeight
});
} catch (error) {
reject(error);
}
};
img.onerror = () => {
reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
};
img.src = imageSrc;
});
}
binarizeImage(imageData) {
const data = imageData.data;
const width = imageData.width;
const height = imageData.height;
const binaryMatrix = [];
for (let y = 0; y < height; y++) {
const row = [];
for (let x = 0; x < width; x++) {
const idx = (y * width + x) * 4;
const r = data[idx];
const g = data[idx + 1];
const b = data[idx + 2];
const gray = 0.299 * r + 0.587 * g + 0.114 * b;
row.push(gray < this.threshold ? 0 : 1);
}
binaryMatrix.push(row);
}
return binaryMatrix;
}
applyOrderedDithering(imageData) {
const data = imageData.data;
const width = imageData.width;
const height = imageData.height;
const result = [];
for (let y = 0; y < height; y++) {
const row = [];
for (let x = 0; x < width; x++) {
const idx = (y * width + x) * 4;
const r = data[idx];
const g = data[idx + 1];
const b = data[idx + 2];
const gray = 0.299 * r + 0.587 * g + 0.114 * b;
const matrixSize = 5;
const mx = x % matrixSize;
const my = y % matrixSize;
const threshold = (this.bayerMatrix5x5[my][mx] + 1) * 255 / 26;
row.push(gray > threshold ? 1 : 0);
}
result.push(row);
}
return result;
}
setThreshold(value) {
this.threshold = value;
}
}
class HorizontalEnhancer {
constructor() {
this.adhesionCoefficient = 2; // é»˜è®¤ç²˜åˆç³»æ•°
this.enableDenoising = true; // é»˜è®¤å¯ç”¨å»å™ªå¤„ç†
this.gapDistanceMap = this.initGapDistanceMap();
this.selfGapMap = {
'ğŸŒ”': 1,
'ğŸŒ“': 2, 
'ğŸŒ’': 3,
'ğŸŒ‘': 4,
'ğŸŒ˜': 3,
'ğŸŒ—': 2,
'ğŸŒ–': 1,
'ğŸŒ•': 0
};
}
setAdhesionCoefficient(coefficient) {
this.adhesionCoefficient = coefficient;
}
setEnableDenoising(enable) {
this.enableDenoising = enable;
}
initGapDistanceMap() {
const map = {};
const moons = ['ğŸŒ‘', 'ğŸŒ˜', 'ğŸŒ—', 'ğŸŒ–', 'ğŸŒ•', 'ğŸŒ”', 'ğŸŒ“', 'ğŸŒ’'];
map['ğŸŒ‘'] = {};
for (const moon of moons) {
map['ğŸŒ‘'][moon] = -1;
}
const distances = {
'ğŸŒ˜': { 'ğŸŒ˜': 3, 'ğŸŒ—': 3, 'ğŸŒ–': 3, 'ğŸŒ•': 3, 'ğŸŒ”': 4, 'ğŸŒ“': 5, 'ğŸŒ’': 6, 'ğŸŒ‘': -1 },
'ğŸŒ—': { 'ğŸŒ˜': 2, 'ğŸŒ—': 2, 'ğŸŒ–': 2, 'ğŸŒ•': 2, 'ğŸŒ”': 3, 'ğŸŒ“': 4, 'ğŸŒ’': 5, 'ğŸŒ‘': -1 },
'ğŸŒ–': { 'ğŸŒ˜': 1, 'ğŸŒ—': 1, 'ğŸŒ–': 1, 'ğŸŒ•': 1, 'ğŸŒ”': 2, 'ğŸŒ“': 3, 'ğŸŒ’': 4, 'ğŸŒ‘': -1 },
'ğŸŒ•': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ”': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ“': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ’': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 }
};
return { ...map, ...distances };
}
getGapDistance(left, right) {
return this.gapDistanceMap[left]?.[right] || 0;
}
performAdhesion(left, right) {
const gap = this.getGapDistance(left, right);
if (gap <= 0 || gap > this.adhesionCoefficient) {
return [left, right];
}
const fillOptions = [
['ğŸŒ•', right], // å·¦è¾¹å˜æ»¡æœˆ
[left, 'ğŸŒ•'],  // å³è¾¹å˜æ»¡æœˆ
['ğŸŒ•', 'ğŸŒ•']   // ä¸¤è¾¹éƒ½å˜æ»¡æœˆ
];
for (const [newLeft, newRight] of fillOptions) {
if (this.getGapDistance(newLeft, newRight) === 0) {
if (newLeft !== left && newRight === right) {
return [newLeft, newRight];
}
if (newLeft === left && newRight !== right) {
return [newLeft, newRight];
}
}
}
return ['ğŸŒ•', 'ğŸŒ•'];
}
selfAdhesion(lines) {
const processedLines = [];
for (let line of lines) {
if (line.length === 0) {
processedLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length; i++) {
const current = chars[i];
if (current === 'ğŸŒ•' || current === 'ğŸŒ‘') {
continue;
}
let leftIsEmpty = false, rightIsEmpty = false;
if (i === 0) {
leftIsEmpty = true; // æœ€å·¦ä¾§è§†ä¸º-1
} else {
leftIsEmpty = (chars[i - 1] === 'ğŸŒ‘');
}
if (i === chars.length - 1) {
rightIsEmpty = true; // æœ€å³ä¾§è§†ä¸º-1
} else {
rightIsEmpty = (chars[i + 1] === 'ğŸŒ‘');
}
if (leftIsEmpty && rightIsEmpty) {
const selfGap = this.selfGapMap[current] || 0;
if (selfGap <= this.adhesionCoefficient) {
newChars[i] = 'ğŸŒ•';
}
}
}
processedLines.push(newChars.join(''));
}
return processedLines;
}
enhance(moonArtText) {
if (this.adhesionCoefficient === 0) {
return moonArtText;
}
const lines = moonArtText.split('\n');
const processedLines = [];
for (let line of lines) {
if (line.length === 0) {
processedLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length - 1; i++) {
const [newLeft, newRight] = this.performAdhesion(newChars[i], newChars[i + 1]);
newChars[i] = newLeft;
newChars[i + 1] = newRight;
}
processedLines.push(newChars.join(''));
}
const selfAdhesedLines = this.selfAdhesion(processedLines);
if (this.enableDenoising) {
return this.denoise(selfAdhesedLines);
} else {
return selfAdhesedLines.join('\n');
}
}
denoise(lines) {
const denoiseLines = [];
for (let line of lines) {
if (line.length === 0) {
denoiseLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length; i++) {
const current = chars[i];
if (current === 'ğŸŒ‘') continue;
let leftGap = -1, rightGap = -1;
if (i > 0) {
leftGap = this.getGapDistance(chars[i - 1], current);
}
if (i < chars.length - 1) {
rightGap = this.getGapDistance(current, chars[i + 1]);
}
if (current !== 'ğŸŒ•' && 
(leftGap > 0 || leftGap === -1) && 
(rightGap > 0 || rightGap === -1)) {
newChars[i] = 'ğŸŒ‘';
}
}
denoiseLines.push(newChars.join(''));
}
return denoiseLines.join('\n');
}
}
class SimpleMoonGenerator {
constructor() {
this.moonPhases = [
{ emoji: 'ğŸŒ‘', minBlack: 0, maxBlack: 0 },    // å…¨ç™½/ç©º
{ emoji: 'ğŸŒ˜', minBlack: 1, maxBlack: 4 },    // å¾ˆå°‘é»‘è‰² 
{ emoji: 'ğŸŒ—', minBlack: 5, maxBlack: 8 },    // å°‘é‡é»‘è‰²
{ emoji: 'ğŸŒ–', minBlack: 9, maxBlack: 12 },   // ä¸­ç­‰é»‘è‰²
{ emoji: 'ğŸŒ•', minBlack: 13, maxBlack: 16 }   // å¤§é‡é»‘è‰²
];
this.verticalProcessingPositions = [];
}
grayToColorLevel(gray) {
return gray < 128 ? 0 : 1; // 0 = é»‘è‰²ï¼Œ1 = ç™½è‰²
}
gridToMoonWithMeta(grid) {
let blackCount = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) { // 0 = é»‘è‰²
blackCount++;
}
}
}
const densityLevel = this.getDensityLevel(blackCount);
const centerX = this.calculateHorizontalCenter(grid);
const bias = this.getBias(centerX);
let originalMoonPhase;
switch (densityLevel.name) {
case 'æä½å¯†åº¦':
originalMoonPhase = 'ğŸŒ‘';
break;
case 'é«˜å¯†åº¦':
originalMoonPhase = 'ğŸŒ•';
break;
case 'ä¸­ä½å¯†åº¦':
case 'ä¸­ç­‰å¯†åº¦':
case 'æ¬¡é«˜å¯†åº¦':
originalMoonPhase = this.selectMoonPhase(densityLevel.name, bias);
break;
default:
originalMoonPhase = 'ğŸŒ‘';
}
return {
originalMoonPhase: originalMoonPhase,
finalMoonPhase: originalMoonPhase, // åˆå§‹æ—¶ä¸åŸå§‹æœˆç›¸ç›¸åŒ
densityLevel: densityLevel.name,
densitySymbol: densityLevel.debugSymbol,
bias: bias,
blackCount: blackCount,
centerX: centerX
};
}
gridToMoon(grid) {
return this.gridToMoonWithMeta(grid).finalMoonPhase;
}
getDensityLevel(blackCount) {
const densityLevels = [
{ name: 'æä½å¯†åº¦', minPixels: 1, maxPixels: 4, debugSymbol: 'â¬›' },
{ name: 'ä¸­ä½å¯†åº¦', minPixels: 5, maxPixels: 8, debugSymbol: 'ğŸŸ¦' },
{ name: 'ä¸­ç­‰å¯†åº¦', minPixels: 9, maxPixels: 14, debugSymbol: 'ğŸŸ§' },
{ name: 'æ¬¡é«˜å¯†åº¦', minPixels: 15, maxPixels: 21, debugSymbol: 'ğŸŸ¨' },
{ name: 'é«˜å¯†åº¦', minPixels: 22, maxPixels: 25, debugSymbol: 'æ— ' }
];
if (blackCount === 0) {
return { name: 'ç©ºç™½', debugSymbol: 'â¬œ' };
}
for (const level of densityLevels) {
if (blackCount >= level.minPixels && blackCount <= level.maxPixels) {
return level;
}
}
return densityLevels[4];
}
calculateHorizontalCenter(grid) {
let weightedX = 0;
let totalBlack = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) { // 0 = é»‘è‰²
weightedX += x;
totalBlack++;
}
}
}
return totalBlack > 0 ? weightedX / totalBlack : 2; // 5x5ä¸­å¿ƒä¸º2
}
getBias(centerX) {
if (centerX < 1.8) {
return 'left';
} else if (centerX > 2.2) {
return 'right';
} else {
return 'balanced';
}
}
selectMoonPhase(densityLevel, bias) {
const phaseMap = {
'ä¸­ä½å¯†åº¦': { left: 'ğŸŒ˜', right: 'ğŸŒ’', balanced: 'ğŸŒ•' },
'ä¸­ç­‰å¯†åº¦': { left: 'ğŸŒ—', right: 'ğŸŒ“', balanced: 'ğŸŒ•' },
'æ¬¡é«˜å¯†åº¦': { left: 'ğŸŒ–', right: 'ğŸŒ”', balanced: 'ğŸŒ•' }
};
return phaseMap[densityLevel]?.[bias] || 'ğŸŒ•';
}
reverseMoon(emoji) {
const reverseMap = {
'ğŸŒ‘': 'ğŸŒ•', // æ–°æœˆ â†” æ»¡æœˆ
'ğŸŒ’': 'ğŸŒ–', // è›¾æœˆ â†” äºæœˆ
'ğŸŒ“': 'ğŸŒ—', // ä¸Šå¼¦æœˆ â†” ä¸‹å¼¦æœˆ
'ğŸŒ”': 'ğŸŒ˜', // å‡¸æœˆ â†” æ®‹æœˆ
'ğŸŒ•': 'ğŸŒ‘', // æ»¡æœˆ â†” æ–°æœˆ
'ğŸŒ–': 'ğŸŒ’', // äºæœˆ â†” è›¾æœˆ
'ğŸŒ—': 'ğŸŒ“', // ä¸‹å¼¦æœˆ â†” ä¸Šå¼¦æœˆ
'ğŸŒ˜': 'ğŸŒ”'  // æ®‹æœˆ â†” å‡¸æœˆ
};
return reverseMap[emoji] || emoji;
}
getCharacterVacancy(moonPhase) {
let normalizedPhase = moonPhase.normalize('NFC').replace(/[\uFE0E\uFE0F]/g, '').trim();
const vacancyMapByCodePoint = {
0x1F314: 1, // ğŸŒ”
0x1F313: 2, // ğŸŒ“  
0x1F312: 3, // ğŸŒ’
0x1F311: 4, // ğŸŒ‘
0x1F318: 3, // ğŸŒ˜
0x1F317: 2, // ğŸŒ—
0x1F316: 1, // ğŸŒ–
0x1F315: 0  // ğŸŒ•
};
const codePoint = normalizedPhase.codePointAt(0);
if (codePoint && vacancyMapByCodePoint.hasOwnProperty(codePoint)) {
return vacancyMapByCodePoint[codePoint];
}
const vacancyMap = {
'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': 4,
'ğŸŒ˜': 3, 'ğŸŒ—': 2, 'ğŸŒ–': 1, 'ğŸŒ•': 0
};
return vacancyMap[normalizedPhase] || 4; // é»˜è®¤ä¸ºæœ€é«˜ç©ºç¼ºåº¦
}
shouldApplyVerticalProcessing(cellMeta, targetDensityLevels) {
return targetDensityLevels.includes(cellMeta.densityLevel) && 
cellMeta.bias === 'balanced';
}
applyVerticalProcessing(gridWithMeta, targetDensityLevels, thresholdN = 2) {
const gridHeight = gridWithMeta.length;
const gridWidth = gridWithMeta[0]?.length || 0;
this.verticalProcessingPositions = [];
for (let row = 1; row < gridHeight; row++) {
for (let col = 0; col < gridWidth; col++) {
const currentCell = gridWithMeta[row][col];
if (this.shouldApplyVerticalProcessing(currentCell, targetDensityLevels)) {
this.verticalProcessingPositions.push({
row: row,
col: col,
densityLevel: currentCell.densityLevel
});
const aboveCell = gridWithMeta[row - 1][col];
const aboveVacancy = this.getCharacterVacancy(aboveCell.finalMoonPhase);
if (aboveVacancy <= thresholdN) {
currentCell.finalMoonPhase = 'ğŸŒ‘';
} else {
currentCell.finalMoonPhase = 'ğŸŒ•';
}
}
}
}
return gridWithMeta;
}
getDensityDebugSymbol(densityLevel) {
const DENSITY_DEBUG_SYMBOLS = {
'ä¸­ç­‰å¯†åº¦': 'ğŸŸ§',  // æ©™è‰²æ–¹å—
'ä¸­ä½å¯†åº¦': 'ğŸŸ¦',  // è“è‰²æ–¹å—  
'æ¬¡é«˜å¯†åº¦': 'ğŸŸ¨',  // é»„è‰²æ–¹å—
'æä½å¯†åº¦': 'â¬›',  // é»‘è‰²æ–¹å—
'é«˜å¯†åº¦': 'ğŸŒ•'     // ä¿æŒåŸæ ·
};
return DENSITY_DEBUG_SYMBOLS[densityLevel] || 'â“';
}
applySpacing(text, spacing) {
if (spacing <= 0) return text;
const lines = text.split('\n');
const spacedLines = [];
for (const line of lines) {
if (line.length === 0) {
spacedLines.push(line);
continue;
}
const chars = Array.from(line);
const spacedChars = [];
for (let i = 0; i < chars.length; i++) {
spacedChars.push(chars[i]);
if (i < chars.length - 1) {
spacedChars.push('ğŸŒ‘'.repeat(spacing));
}
}
spacedLines.push(spacedChars.join(''));
}
return spacedLines.join('\n');
}
applyPadding(text, padding) {
if (padding <= 0) return text;
const lines = text.split('\n');
if (lines.length === 0) return text;
const maxWidth = Math.max(...lines.map(line => Array.from(line).length));
const paddingChar = 'ğŸŒ‘';
const horizontalPadding = paddingChar.repeat(padding);
const fullPaddingLine = paddingChar.repeat(maxWidth + 2 * padding);
const paddedLines = [];
for (let i = 0; i < padding; i++) {
paddedLines.push(fullPaddingLine);
}
for (const line of lines) {
const chars = Array.from(line);
while (chars.length < maxWidth) {
chars.push('ğŸŒ‘');
}
const paddedLine = horizontalPadding + chars.join('') + horizontalPadding;
paddedLines.push(paddedLine);
}
for (let i = 0; i < padding; i++) {
paddedLines.push(fullPaddingLine);
}
return paddedLines.join('\n');
}
generateFromPixelMatrix(pixelMatrix, width, height, enableVerticalProcessing = true, padding = 0) {
this.verticalProcessingPositions = [];
const metaGrid = [];
const gridSize = 5;
for (let y = 0; y < height; y += gridSize) {
const metaRow = [];
for (let x = 0; x < width; x += gridSize) {
const subGrid = [];
for (let dy = 0; dy < gridSize; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < gridSize; dx++) {
const py = y + dy;
const px = x + dx;
if (py < height && px < width) {
subGrid[dy][dx] = pixelMatrix[py][px];
} else {
subGrid[dy][dx] = 1; // è¶…å‡ºè¾¹ç•Œé»˜è®¤ä¸ºç™½è‰²
}
}
}
const cellMeta = this.gridToMoonWithMeta(subGrid);
metaRow.push(cellMeta);
}
if (metaRow.length > 0) {
metaGrid.push(metaRow);
}
}
if (enableVerticalProcessing) {
const targetDensityLevels = [];
if (document.getElementById('verticalMedium').checked) {
targetDensityLevels.push('ä¸­ç­‰å¯†åº¦');
}
if (document.getElementById('verticalHigh').checked) {
targetDensityLevels.push('æ¬¡é«˜å¯†åº¦');
}
const thresholdN = 2; // é»˜è®¤é˜ˆå€¼
this.applyVerticalProcessing(metaGrid, targetDensityLevels, thresholdN);
}
const resultLines = metaGrid.map(row => 
row.map(cell => cell.finalMoonPhase).join('')
);
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
generateFromImage(pixelMatrix, width, height, padding = 0) {
const metaGrid = [];
const gridSize = 5;
for (let y = 0; y < height; y += gridSize) {
const metaRow = [];
for (let x = 0; x < width; x += gridSize) {
const subGrid = [];
for (let dy = 0; dy < gridSize; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < gridSize; dx++) {
const py = y + dy;
const px = x + dx;
if (py < height && px < width) {
subGrid[dy][dx] = pixelMatrix[py][px];
} else {
subGrid[dy][dx] = 1; // è¶…å‡ºè¾¹ç•Œé»˜è®¤ä¸ºç™½è‰²
}
}
}
const moonPhase = this.gridToMoonForImage(subGrid);
metaRow.push(moonPhase);
}
if (metaRow.length > 0) {
metaGrid.push(metaRow);
}
}
const resultLines = metaGrid.map(row => row.join(''));
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
gridToMoonForImage(grid) {
let blackCount = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) {
blackCount++;
}
}
}
const ratio = blackCount / 25;
if (ratio === 0) return 'ğŸŒ‘';        // 0% - å…¨ç™½èƒŒæ™¯
else if (ratio <= 0.125) return 'ğŸŒ˜'; // 0-12.5% - æå°‘é»‘è‰²
else if (ratio <= 0.25) return 'ğŸŒ—';  // 12.5-25% - å°‘é‡é»‘è‰²
else if (ratio <= 0.375) return 'ğŸŒ–'; // 25-37.5% - è¾ƒå°‘é»‘è‰²
else if (ratio <= 0.5) return 'ğŸŒ•';   // 37.5-50% - ä¸­ç­‰é»‘è‰²
else if (ratio <= 0.625) return 'ğŸŒ”'; // 50-62.5% - è¾ƒå¤šé»‘è‰²
else if (ratio <= 0.75) return 'ğŸŒ“';  // 62.5-75% - å¤§é‡é»‘è‰²
else if (ratio <= 0.875) return 'ğŸŒ’'; // 75-87.5% - æå¤šé»‘è‰²
else return 'ğŸŒ‘';                     // 87.5-100% - å‡ ä¹å…¨é»‘
}
generateSingleChar(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
if (!char.trim()) return [];
const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
const baseFontSize = Math.max(sizeParam * 5, 50); // ç¡®ä¿å­—ç¬¦è¶³å¤Ÿå¤§ï¼ˆ5x5ç³»ç»Ÿï¼‰
const canvasWidth = baseFontSize * 2;   // ç»™å­—ç¬¦è¶³å¤Ÿçš„å®½åº¦ç©ºé—´
const canvasHeight = baseFontSize * 2;  // ç»™å­—ç¬¦è¶³å¤Ÿçš„é«˜åº¦ç©ºé—´
const canvas = document.createElement('canvas');
canvas.width = canvasWidth;
canvas.height = canvasHeight;
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = 'black';
ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const x = canvas.width / 2;
const y = canvas.height / 2;
ctx.fillText(char, x, y);
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const pixelMatrix = [];
for (let y = 0; y < canvas.height; y++) {
pixelMatrix[y] = [];
for (let x = 0; x < canvas.width; x++) {
const idx = (y * canvas.width + x) * 4;
const gray = 0.299 * imageData.data[idx] + 
0.587 * imageData.data[idx + 1] + 
0.114 * imageData.data[idx + 2];
pixelMatrix[y][x] = this.grayToColorLevel(gray);
}
}
let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
let foundText = false;
for (let y = 0; y < canvas.height; y++) {
for (let x = 0; x < canvas.width; x++) {
if (pixelMatrix[y][x] === 0) {
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
foundText = true;
}
}
}
if (!foundText) {
if (isVertical) {
const defaultLine = 'ğŸŒ•'.repeat(sizeParam);
return [defaultLine, defaultLine, defaultLine];
} else {
const result = [];
for (let i = 0; i < sizeParam; i++) {
result.push('ğŸŒ•ğŸŒ•ğŸŒ•');
}
return result;
}
}
const charWidth = maxX - minX + 1;
const charHeight = maxY - minY + 1;
let targetPixelWidth, targetPixelHeight;
if (isVertical) {
targetPixelWidth = sizeParam * 5;
targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
} else {
targetPixelHeight = sizeParam * 5;
targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
}
const gridSize = 5;
const resultLines = [];
for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
let line = '';
for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
const subGrid = [];
for (let dy = 0; dy < 5; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < 5; dx++) {
const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
} else {
subGrid[dy][dx] = 1; // ç™½è‰²
}
}
}
line += this.gridToMoon(subGrid);
}
resultLines.push(line);
}
return resultLines;
}
combineVertically(charResults, spacing, sizeParam) {
if (charResults.length === 0) return '';
let combinedLines = [];
for (let i = 0; i < charResults.length; i++) {
const charLines = charResults[i];
combinedLines.push(...charLines);
if (i < charResults.length - 1 && spacing > 0) {
const spacingLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
for (let j = 0; j < spacing; j++) {
combinedLines.push(spacingLine);
}
}
}
return combinedLines.join('\n');
}
combineHorizontally(charResults, spacing, sizeParam) {
if (charResults.length === 0) return '';
const maxLines = Math.max(...charResults.map(result => result.length));
const normalizedResults = charResults.map(result => {
const normalized = [...result];
const emptyLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
while (normalized.length < maxLines) {
normalized.push(emptyLine);
}
return normalized;
});
const finalLines = [];
for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
let combinedLine = '';
for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
combinedLine += normalizedResults[charIndex][lineIndex];
if (charIndex < normalizedResults.length - 1 && spacing > 0) {
combinedLine += 'ğŸŒ‘'.repeat(spacing);
}
}
finalLines.push(combinedLine);
}
return finalLines.join('\n');
}
generateSingleCharWithMeta(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
if (!char.trim()) return [];
const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
const baseFontSize = Math.max(sizeParam * 5, 50);
const canvasWidth = baseFontSize * 2;
const canvasHeight = baseFontSize * 2;
const canvas = document.createElement('canvas');
canvas.width = canvasWidth;
canvas.height = canvasHeight;
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = 'black';
ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const x = canvas.width / 2;
const y = canvas.height / 2;
ctx.fillText(char, x, y);
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const pixelMatrix = [];
for (let y = 0; y < canvas.height; y++) {
pixelMatrix[y] = [];
for (let x = 0; x < canvas.width; x++) {
const idx = (y * canvas.width + x) * 4;
const gray = 0.299 * imageData.data[idx] + 
0.587 * imageData.data[idx + 1] + 
0.114 * imageData.data[idx + 2];
pixelMatrix[y][x] = this.grayToColorLevel(gray);
}
}
let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
let foundText = false;
for (let y = 0; y < canvas.height; y++) {
for (let x = 0; x < canvas.width; x++) {
if (pixelMatrix[y][x] === 0) {
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
foundText = true;
}
}
}
if (!foundText) {
const defaultSize = isVertical ? [sizeParam, 3] : [3, sizeParam];
const defaultGrid = [];
for (let row = 0; row < defaultSize[1]; row++) {
defaultGrid[row] = [];
for (let col = 0; col < defaultSize[0]; col++) {
defaultGrid[row][col] = this.gridToMoonWithMeta(Array(5).fill().map(() => Array(5).fill(0)));
}
}
return defaultGrid;
}
const charWidth = maxX - minX + 1;
const charHeight = maxY - minY + 1;
let targetPixelWidth, targetPixelHeight;
if (isVertical) {
targetPixelWidth = sizeParam * 5;
targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
} else {
targetPixelHeight = sizeParam * 5;
targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
}
const gridSize = 5;
const metaGrid = [];
for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
const metaRow = [];
for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
const subGrid = [];
for (let dy = 0; dy < 5; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < 5; dx++) {
const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
} else {
subGrid[dy][dx] = 1; // ç™½è‰²
}
}
}
metaRow.push(this.gridToMoonWithMeta(subGrid));
}
metaGrid.push(metaRow);
}
return metaGrid;
}
generate(text, sizeParam = 20, fontType = 'custom', isVertical = true, reverseColor = false, spacing = 0, enableVerticalProcessing = true, padding = 0) {
if (!text.trim()) return '';
const chars = Array.from(text);
if (enableVerticalProcessing) {
const charMetaResults = chars.map(char => {
return this.generateSingleCharWithMeta(char, sizeParam, fontType, isVertical);
});
let globalMetaGrid = [];
let maxCharWidth = 0;
if (isVertical) {
for (let charIndex = 0; charIndex < charMetaResults.length; charIndex++) {
const charMeta = charMetaResults[charIndex];
maxCharWidth = Math.max(maxCharWidth, charMeta[0]?.length || 0);
globalMetaGrid.push(...charMeta);
if (charIndex < charMetaResults.length - 1 && spacing > 0) {
for (let s = 0; s < spacing; s++) {
const spacingRow = [];
for (let col = 0; col < (charMeta[0]?.length || sizeParam); col++) {
spacingRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
globalMetaGrid.push(spacingRow);
}
}
}
} else {
const maxLines = Math.max(...charMetaResults.map(result => result.length));
const normalizedResults = charMetaResults.map(result => {
const normalized = [...result];
const charWidth = result[0]?.length || sizeParam;
while (normalized.length < maxLines) {
const emptyRow = [];
for (let col = 0; col < charWidth; col++) {
emptyRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
normalized.push(emptyRow);
}
return normalized;
});
for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
const combinedRow = [];
for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
combinedRow.push(...normalizedResults[charIndex][lineIndex]);
if (charIndex < normalizedResults.length - 1 && spacing > 0) {
for (let s = 0; s < spacing; s++) {
combinedRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
}
}
globalMetaGrid.push(combinedRow);
}
}
const targetDensityLevels = [];
if (document.getElementById('verticalMedium') && document.getElementById('verticalMedium').checked) {
targetDensityLevels.push('ä¸­ç­‰å¯†åº¦');
}
if (document.getElementById('verticalHigh') && document.getElementById('verticalHigh').checked) {
targetDensityLevels.push('æ¬¡é«˜å¯†åº¦');
}
const thresholdN = 2; // é»˜è®¤é˜ˆå€¼
globalMetaGrid = this.applyVerticalProcessing(globalMetaGrid, targetDensityLevels, thresholdN);
console.error(`ğŸ” éªŒè¯å‚ç›´åŒ–å¤„ç†ç»“æœ:`);
let avoidCount = 0, keepCount = 0;
this.verticalProcessingPositions.forEach(pos => {
if (pos.row < globalMetaGrid.length && pos.col < globalMetaGrid[pos.row].length) {
const cell = globalMetaGrid[pos.row][pos.col];
console.error(`éªŒè¯ä½ç½®(${pos.row},${pos.col}): finalMoonPhase=${cell.finalMoonPhase}, å¯†åº¦=${cell.densityLevel}`);
if (cell.finalMoonPhase === 'ğŸŒ‘') {
avoidCount++;
} else if (cell.finalMoonPhase === 'ğŸŒ•') {
keepCount++;
}
}
});
console.error(`ğŸ“Š å‚ç›´åŒ–å¤„ç†ç»Ÿè®¡: é¿è®©ğŸŒ‘=${avoidCount}ä¸ª, ä¿æŒğŸŒ•=${keepCount}ä¸ª`);
const resultLines = globalMetaGrid.map(row => 
row.map(cell => cell.finalMoonPhase).join('')
);
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
} else {
const charResults = chars.map(char => {
return this.generateSingleChar(char, sizeParam, fontType, isVertical);
});
let result;
if (isVertical) {
result = this.combineVertically(charResults, spacing, sizeParam);
} else {
result = this.combineHorizontally(charResults, spacing, sizeParam);
}
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
}
}
const FONT_FAMILIES = {
'default': 'sans-serif',
'monospace': 'monospace',
'sans-serif': 'sans-serif',
'serif': 'serif'
};
const FONT_CONFIGS = {
'default': { 
adhesionCoefficient: 2,
verticalDensityLevels: ['ä¸­ç­‰å¯†åº¦', 'æ¬¡é«˜å¯†åº¦']
},
'monospace': { 
adhesionCoefficient: 2,
verticalDensityLevels: ['ä¸­ç­‰å¯†åº¦', 'æ¬¡é«˜å¯†åº¦']
},
'sans-serif': { 
adhesionCoefficient: 3,
verticalDensityLevels: []  // ä¸ä½¿ç”¨å‚ç›´åŒ–å¤„ç†
},
'serif': { 
adhesionCoefficient: 2,
verticalDensityLevels: ['ä¸­ç­‰å¯†åº¦', 'æ¬¡é«˜å¯†åº¦']
}
};
const generator = new SimpleMoonGenerator();
const horizontalEnhancer = new HorizontalEnhancer();
function copyToClipboard() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('Generated result will appear here')) return;
navigator.clipboard.writeText(moonArt).then(() => {
const copyBtn = document.getElementById('copyBtn');
const btnText = copyBtn.querySelector('.btn-text');
const originalText = btnText.textContent;
btnText.textContent = 'Copied!';
copyBtn.classList.add('success');
setTimeout(() => {
btnText.textContent = originalText;
copyBtn.classList.remove('success');
}, 2000);
}).catch(err => {
console.error('Copy failed:', err);
});
}
function downloadText() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('Generated result will appear here')) return;
const randomId = Math.random().toString(36).substring(2, 8);
const filename = `moon-art-${randomId}-${Date.now()}.txt`;
const blob = new Blob([moonArt], { type: 'text/plain;charset=utf-8' });
const url = URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.click();
URL.revokeObjectURL(url);
}
function downloadImage() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('Generated result will appear here')) return;
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const lines = moonArt.split('\n');
const fontSize = 20;
const lineHeight = fontSize;
canvas.width = lines[0].length * fontSize / 2;
canvas.height = lines.length * lineHeight;
ctx.fillStyle = 'black';
ctx.font = `${fontSize}px sans-serif`;
ctx.textBaseline = 'top';
lines.forEach((line, lineIndex) => {
let x = 0;
for (let i = 0; i < line.length; i += 2) {
const emoji = line.substr(i, 2);
ctx.fillText(emoji, x, lineIndex * lineHeight);
x += fontSize;
}
});
const randomId = Math.random().toString(36).substring(2, 8);
const filename = `moon-art-${randomId}-${Date.now()}.png`;
canvas.toBlob((blob) => {
const url = URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.click();
URL.revokeObjectURL(url);
}, 'image/png');
}
function updatePreview() {
if (currentInputMode === 'image' && lastUploadedImageSrc) {
generateFromImage(lastUploadedImageSrc);
} else if (currentInputMode === 'text') {
updateTextPreview();
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
}
}
function updateTextPreview() {
const text = document.getElementById('textInput').value.trim();
const sizeValue = parseInt(document.getElementById('heightSlider').value);
const fontType = document.querySelector('input[name="fontType"]:checked')?.value || 'monospace';
const adhesionCoefficient = 2; // Fixed value for English version
const spacing = parseInt(document.getElementById('spacingSlider').value);
const padding = parseInt(document.getElementById('paddingSlider').value);
const selectedRadio = document.querySelector('input[name="direction"]:checked');
const isVertical = selectedRadio?.value === 'vertical';
const reverseColor = document.getElementById('reverseColor').checked;
const enableDenoising = document.getElementById('enableDenoising')?.checked || true;
if (!text) {
document.getElementById('moonArt').textContent = '';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
return;
}
try {
let result = generator.generate(text, sizeValue, fontType, isVertical, false, spacing, true, padding);
if (generator.verticalProcessingPositions.length > 0) {
const lines = result.split('\n');
generator.verticalProcessingPositions.forEach(pos => {
if (pos.row < lines.length && pos.col < lines[pos.row].length) {
const char = Array.from(lines[pos.row])[pos.col];
}
});
}
horizontalEnhancer.setAdhesionCoefficient(adhesionCoefficient);
horizontalEnhancer.setEnableDenoising(enableDenoising);
result = horizontalEnhancer.enhance(result);
if (generator.verticalProcessingPositions.length > 0) {
const linesFinal = result.split('\n');
let moon_count = 0, black_count = 0;
generator.verticalProcessingPositions.forEach(pos => {
if (pos.row < linesFinal.length && pos.col < linesFinal[pos.row].length) {
const charFinal = Array.from(linesFinal[pos.row])[pos.col];
if (charFinal === 'ğŸŒ•') moon_count++;
else if (charFinal === 'ğŸŒ‘') black_count++;
}
});
console.error(`ğŸ“Š Vertical processing statistics: ğŸŒ•=${moon_count}, ğŸŒ‘=${black_count}`);
const allChars = result.replace(/\n/g, '');
const totalMoon = (allChars.match(/ğŸŒ•/g) || []).length;
const totalBlack = (allChars.match(/ğŸŒ‘/g) || []).length;
console.error(`ğŸ“Š Overall character statistics: TotalğŸŒ•=${totalMoon}, TotalğŸŒ‘=${totalBlack}`);
}
if (reverseColor) {
result = Array.from(result).map(char => {
if (char === '\n') return char;
return generator.reverseMoon(char);
}).join('');
}
document.getElementById('moonArt').textContent = result;
document.getElementById('actionButtons').style.display = 'flex';
} catch (error) {
console.error('Generation error:', error);
document.getElementById('moonArt').textContent = 'Error occurred';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
}
}
function isMobileDevice() {
return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
(navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
window.innerWidth <= 768;
}
document.addEventListener('DOMContentLoaded', () => {
const heightSlider = document.getElementById('heightSlider');
const heightValue = document.getElementById('heightValue');
const spacingSlider = document.getElementById('spacingSlider');
const spacingValue = document.getElementById('spacingValue');
const paddingSlider = document.getElementById('paddingSlider');
const paddingValue = document.getElementById('paddingValue');
heightSlider.addEventListener('input', () => {
heightValue.textContent = heightSlider.value;
if (currentInputMode === 'text') {
textModeSettings.height = parseInt(heightSlider.value);
} else {
imageModeSettings.height = parseInt(heightSlider.value);
}
updatePreview();
});
const imageHeightSlider = document.getElementById('imageHeightSlider');
const imageHeightValue = document.getElementById('imageHeightValue');
imageHeightSlider.addEventListener('input', () => {
imageHeightValue.textContent = imageHeightSlider.value;
imageModeSettings.height = parseInt(imageHeightSlider.value);
updatePreview();
});
spacingSlider.addEventListener('input', () => {
spacingValue.textContent = spacingSlider.value;
updatePreview();
});
paddingSlider.addEventListener('input', () => {
paddingValue.textContent = paddingSlider.value;
if (currentInputMode === 'text') {
textModeSettings.padding = parseInt(paddingSlider.value);
} else {
imageModeSettings.padding = parseInt(paddingSlider.value);
}
updatePreview();
});
const imagePaddingSlider = document.getElementById('imagePaddingSlider');
const imagePaddingValue = document.getElementById('imagePaddingValue');
imagePaddingSlider.addEventListener('input', () => {
imagePaddingValue.textContent = imagePaddingSlider.value;
imageModeSettings.padding = parseInt(imagePaddingSlider.value);
updatePreview();
});
document.getElementById('textInput').addEventListener('input', updatePreview);
document.querySelectorAll('input[name="fontType"]').forEach(radio => {
radio.addEventListener('change', updatePreview);
});
document.querySelectorAll('input[name="direction"]').forEach(radio => {
radio.addEventListener('change', updatePreview);
});
document.getElementById('reverseColor').addEventListener('change', updatePreview);
document.getElementById('imageReverseColor').addEventListener('change', updatePreview);
if (document.getElementById('enableDenoising')) {
document.getElementById('enableDenoising').addEventListener('change', updatePreview);
}
document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
document.getElementById('downloadTextBtn').addEventListener('click', downloadText);
document.getElementById('downloadImageBtn').addEventListener('click', downloadImage);
const currentSelection = document.querySelector('input[name="direction"]:checked');
if (!currentSelection) {
if (isMobileDevice()) {
document.querySelector('input[name="direction"][value="vertical"]').checked = true;
} else {
document.querySelector('input[name="direction"][value="horizontal"]').checked = true;
}
}
initializeTabs();
initializeImageUpload();
setTimeout(() => {
updatePreview();
}, 0);
});
function initializeTabs() {
const tabButtons = document.querySelectorAll('.tab-button');
const tabContents = document.querySelectorAll('.tab-content');
tabButtons.forEach(button => {
button.addEventListener('click', () => {
const tabId = button.getAttribute('data-tab');
tabButtons.forEach(btn => btn.classList.remove('active'));
tabContents.forEach(content => content.classList.remove('active'));
button.classList.add('active');
if (tabId === 'text') {
document.getElementById('textTab').classList.add('active');
if (currentInputMode === 'image') {
imageModeSettings.height = parseInt(document.getElementById('imageHeightSlider').value);
imageModeSettings.padding = parseInt(document.getElementById('imagePaddingSlider').value);
}
currentInputMode = 'text'; // Update current mode
const heightSlider = document.getElementById('heightSlider');
const heightMaxLabel = heightSlider.nextElementSibling;
heightSlider.max = 60;
heightMaxLabel.textContent = '60';
heightSlider.value = textModeSettings.height;
document.getElementById('heightValue').textContent = textModeSettings.height;
document.getElementById('paddingSlider').value = textModeSettings.padding;
document.getElementById('paddingValue').textContent = textModeSettings.padding;
const textInput = document.getElementById('textInput').value.trim();
if (textInput) {
setTimeout(() => updatePreview(), 0);
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('debugInfo').style.display = 'none';
document.getElementById('actionButtons').style.display = 'none';
}
} else if (tabId === 'image') {
document.getElementById('imageTab').classList.add('active');
if (currentInputMode === 'text') {
textModeSettings.height = parseInt(document.getElementById('heightSlider').value);
textModeSettings.padding = parseInt(document.getElementById('paddingSlider').value);
}
currentInputMode = 'image'; // Update current mode
if (lastUploadedImageSrc) {
setTimeout(() => updatePreview(), 0);
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('debugInfo').style.display = 'none';
document.getElementById('actionButtons').style.display = 'none';
}
}
});
});
}
function initializeImageUpload() {
const imageInput = document.getElementById('imageInput');
const uploadArea = document.getElementById('uploadArea');
uploadArea.addEventListener('click', () => {
imageInput.click();
});
imageInput.addEventListener('change', handleFileSelect);
uploadArea.addEventListener('dragover', (e) => {
e.preventDefault();
uploadArea.classList.add('drag-over');
});
uploadArea.addEventListener('dragleave', (e) => {
e.preventDefault();
uploadArea.classList.remove('drag-over');
});
uploadArea.addEventListener('drop', (e) => {
e.preventDefault();
uploadArea.classList.remove('drag-over');
const files = e.dataTransfer.files;
if (files.length > 0 && files[0].type.startsWith('image/')) {
handleFile(files[0]);
}
});
function handleFileSelect(e) {
const file = e.target.files[0];
if (file && file.type.startsWith('image/')) {
handleFile(file);
}
}
function handleFile(file) {
const reader = new FileReader();
reader.onload = (e) => {
lastUploadedImageSrc = e.target.result;
currentInputMode = 'image';
setTimeout(() => {
generateFromImage(e.target.result);
}, 100);
};
reader.readAsDataURL(file);
}
}
async function generateFromImage(imageSrc) {
try {
document.getElementById('moonArt').textContent = 'Processing...';
const height = parseInt(document.getElementById('imageHeightSlider').value);
const padding = parseInt(document.getElementById('imagePaddingSlider').value);
const reverseColor = document.getElementById('imageReverseColor').checked;
const enableDenoising = document.getElementById('enableDenoising')?.checked || true;
const adhesionCoefficient = 2; // Fixed value
const imageProcessor = new ImageProcessor();
const imageData = await imageProcessor.loadAndProcessImage(imageSrc, height, true);
const generator = new SimpleMoonGenerator();
let result = generator.generateFromImage(
imageData.matrix,
imageData.width,
imageData.height,
padding // Pass padding parameter directly
);
if (reverseColor) {
result = result.split('\n').map(line => {
return Array.from(line).map(char => {
return generator.reverseMoon(char);
}).join('');
}).join('\n');
}
document.getElementById('moonArt').textContent = result;
document.getElementById('actionButtons').style.display = 'flex';
document.getElementById('debugInfo').style.display = 'none';
} catch (error) {
console.error('Image processing failed:', error);
document.getElementById('moonArt').textContent = 'Error: Failed to process image';
document.getElementById('actionButtons').style.display = 'none';
}
}
</script>
</body>
</html>
