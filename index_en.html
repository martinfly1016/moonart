<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moon Character Generator | Create Moon Emoji Art | Free Text Converter - MojiMoon</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Free online tool to convert text and images into beautiful moon emoji art. Supports vertical and horizontal layouts, multiple fonts. Create unique ASCII art using moon phases!">
    <meta name="keywords" content="moon characters,emoji art,text art,generator,free tool,moon phases,ASCII art">
    <meta name="author" content="Moon Character Generator">
    <meta name="robots" content="index,follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Moon Character Generator">
    <meta property="og:description" content="Convert text to moon emoji art - Free online tool">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mojimoon.com/index_en.html">
    <meta property="og:image" content="https://mojimoon.com/moon_icon.png">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@mojimoon">
    <meta name="twitter:title" content="Moon Character Generator">
    <meta name="twitter:description" content="Convert text to moon emoji art">
    <meta name="twitter:image" content="https://mojimoon.com/moon_icon.png">
    
    <!-- Favicon -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌙</text></svg>">
    <link rel="icon" type="image/png" sizes="32x32" href="/moon_icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/moon_icon.png">
    <link rel="apple-touch-icon" href="/moon_icon.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://mojimoon.com/index_en.html">
    
    <!-- Hreflang -->
    <link rel="alternate" href="https://mojimoon.com/" hreflang="ja">
    <link rel="alternate" href="https://mojimoon.com/index_en.html" hreflang="en">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Moon Character Generator",
        "description": "Convert text to moon emoji art",
        "applicationCategory": "UtilityApplication",
        "operatingSystem": "All",
        "inLanguage": "en",
        "isAccessibleForFree": true
    }
    </script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WD9XP5ERGX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WD9XP5ERGX');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        .guide-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            margin-right: 10px;
        }
        
        .guide-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .lang-switcher {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }
        
        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 18px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .text-input {
            width: 100%;
            height: 48px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
        }
        
        .text-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .height-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .height-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .height-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #8b5cf6;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .form-group h3 span,
        .control-item h3 span {
            color: #fbbf24;
            font-weight: 600;
        }
        
        .dual-control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 12px;
        }
        
        .control-item h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: white;
            font-weight: 600;
        }
        
        .input-tabs {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tab-button.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .upload-area.drag-over {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }
        
        .radio-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }
        
        .radio-option:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: #8b5cf6;
        }
        
        .radio-option input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #8b5cf6;
        }
        
        .radio-label {
            font-weight: 500;
            user-select: none;
        }
        
        .generate-btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .generate-btn:hover {
            background: linear-gradient(135deg, #7c3aed, #6d28d9);
            transform: translateY(-1px);
        }
        
        .generate-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
        }
        
        .moon-art {
            font-family: monospace;
            line-height: 1.4;
            letter-spacing: 0.1em;
            white-space: pre;
            width: fit-content;
            color: #fff;
            padding-top: 5px;
        }
        
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            flex: 1;
            min-width: 140px;
        }
        
        .copy-btn {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .copy-btn:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
        }
        
        .download-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        }
        
        .download-btn:hover {
            background: linear-gradient(135deg, #1d4ed8, #1e40af);
            transform: translateY(-1px);
        }
        
        .hidden {
            display: none !important;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-text {
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        .upload-hint {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .preview-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        @media (max-width: 768px) {
            .header {
                margin-bottom: 15px;
            }
            
            .header h1 {
                font-size: 1.5rem;
                margin-bottom: 5px;
            }
            
            .guide-link {
                font-size: 13px;
                padding: 6px 12px;
            }
            
            .lang-switcher {
                font-size: 13px;
                padding: 6px 12px;
            }
            
            .control-panel {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .form-group {
                margin-bottom: 10px;
            }
            
            .form-group h3 {
                font-size: 1.1rem;
                margin-bottom: 10px;
            }
            
            .radio-group {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .action-btn {
                min-width: auto;
            }
            
            .upload-area {
                padding: 30px 15px;
            }
            
            .height-control {
                gap: 10px;
            }
            
            .dual-control-group {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
        
        /* 隐藏调试参数 */
        .debug-section {
            display: none !important;
        }
        
        .debug-header {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            color: #fbbf24;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .debug-header:hover {
            background: rgba(255, 193, 7, 0.25);
            border-color: rgba(255, 193, 7, 0.4);
        }
        
        .debug-content {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }
        
        .debug-content.expanded {
            display: block;
        }
        
        .debug-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .debug-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .debug-control label {
            font-size: 12px;
            color: #fbbf24;
            font-weight: 500;
        }
        
        .debug-control input, .debug-control select {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }
        
        .debug-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            color: #fbbf24;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <button id="favoriteBtn" class="favorite-btn" style="
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        font-size: 14px;
        cursor: pointer;
        backdrop-filter: blur(10px);
        transition: all 0.2s ease;
        display: none;
    ">
        ⭐ Favorite
    </button>
    
    <div class="container">
        <header class="header">
            <h1>🌙 Moon Character Generator</h1>
            <a href="guide_en.html" class="guide-link">📖 User Guide</a>
            <a href="index.html" class="lang-switcher">🌏 日本語</a>
        </header>
        
        <div class="control-panel">
            <!-- Input Mode Tabs -->
            <div class="input-tabs">
                <button class="tab-button active" data-tab="text">Text Input</button>
                <button class="tab-button" data-tab="image">Image Input</button>
            </div>
            
            <!-- Text Input Tab Content -->
            <div class="tab-content active" id="textTab">
                <div class="form-group">
                    <label for="textInput">Text Input</label>
                    <input type="text" id="textInput" class="text-input" placeholder="Enter text to convert..." maxlength="50">
                </div>
                
                <div class="form-group">
                    <h3>Height: <span id="heightValue">10</span> rows</h3>
                    <div class="height-control">
                        <span>10</span>
                        <input type="range" id="heightSlider" class="height-slider" min="10" max="60" value="10">
                        <span>60</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <h3>Font Style</h3>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="fontType" value="monospace" checked>
                            <span class="radio-label">Monospace</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="fontType" value="sans-serif">
                            <span class="radio-label">Sans-serif</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="fontType" value="serif">
                            <span class="radio-label">Serif</span>
                        </label>
                    </div>
                </div>
                
                <div class="form-group">
                    <h3>Text Direction</h3>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="direction" value="vertical">
                            <span class="radio-label">Vertical</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="direction" value="horizontal" checked>
                            <span class="radio-label">Horizontal</span>
                        </label>
                    </div>
                </div>
                
                <div class="dual-control-group">
                    <div class="control-item">
                        <h3>Spacing: <span id="spacingValue">2</span></h3>
                        <div class="height-control">
                            <span>0</span>
                            <input type="range" id="spacingSlider" class="height-slider" min="0" max="10" value="2">
                            <span>10</span>
                        </div>
                    </div>
                    <div class="control-item">
                        <h3>Padding: <span id="paddingValue">0</span></h3>
                        <div class="height-control">
                            <span>0</span>
                            <input type="range" id="paddingSlider" class="height-slider" min="0" max="10" value="0">
                            <span>10</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <h3>Options</h3>
                    <div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
                        <input type="checkbox" id="reverseColor" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
                        <label for="reverseColor" style="cursor: pointer; font-weight: 600;">Reverse Color</label>
                    </div>
                </div>
            </div>
            
            <!-- Image Input Tab Content -->
            <div class="tab-content" id="imageTab">
                <div class="form-group">
                    <label>Image Upload</label>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-text">📁 Click to select image or drag and drop</div>
                        <div class="upload-hint">Supports JPG, PNG, GIF formats</div>
                    </div>
                    <input type="file" id="imageInput" class="file-input" accept="image/*">
                </div>
                
                <div class="form-group">
                    <h3>Height: <span id="imageHeightValue">60</span> rows</h3>
                    <div class="height-control">
                        <span>10</span>
                        <input type="range" id="imageHeightSlider" class="height-slider" min="10" max="500" value="60">
                        <span>500</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <h3>Padding: <span id="imagePaddingValue">0</span></h3>
                    <div class="height-control">
                        <span>0</span>
                        <input type="range" id="imagePaddingSlider" class="height-slider" min="0" max="10" value="0">
                        <span>10</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <h3>Options</h3>
                    <div style="display: flex; gap: 20px;">
                        <div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
                            <input type="checkbox" id="imageReverseColor" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
                            <label for="imageReverseColor" style="cursor: pointer; font-weight: 600;">Reverse Color</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
                            <input type="checkbox" id="enableDenoising" checked style="width: 18px; height: 18px; accent-color: #8b5cf6;">
                            <label for="enableDenoising" style="cursor: pointer; font-weight: 600;">Noise Reduction</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div id="actionButtons" class="action-buttons" style="display: none;">
                <button id="copyBtn" class="action-btn copy-btn">
                    <span class="btn-icon">📋</span>
                    <span class="btn-text">Copy</span>
                </button>
                <button id="downloadTextBtn" class="action-btn download-btn">
                    <span class="btn-icon">📄</span>
                    <span class="btn-text">Download Text</span>
                </button>
                <button id="downloadImageBtn" class="action-btn download-btn">
                    <span class="btn-icon">🖼️</span>
                    <span class="btn-text">Download Image</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Preview Panel (expandable) -->
    <div class="container" style="max-width: none; min-width: 800px; width: fit-content;">
        <div class="preview-panel">
            <h2 style="margin-bottom: 8px; font-size: 12px; font-weight: 600;">Preview</h2>
            
            <!-- Debug info for vertical processing -->
            <div id="debugInfo" style="margin-bottom: 10px; font-size: 11px; color: #fbbf24; font-family: monospace; display: none !important;">
                <div>Vertical Processing: <span id="verticalProcessingStatus">Enabled</span></div>
                <div>Target Density Levels: <span id="targetDensityLevels">Medium Density</span></div>
                <div>Threshold n: <span id="thresholdN">2</span></div>
                <div>Processing Mode: <span id="processingMode">Medium Density (Balance Center Only)</span></div>
            </div>
            
            <div id="moonArt" class="moon-art"><!-- Generated result will appear here --></div>
            
            <!-- Debug controls (hidden for production) -->
            <div style="margin-top: 20px; display: none;">
                <label>
                    <input type="checkbox" id="showDebugCanvas"> Show Original Canvas Debug
                </label>
            </div>
            
            <!-- Debug canvas (hidden for production) -->
            <canvas id="debugCanvas" style="border: 1px solid #666; margin-top: 10px; background: white; display: none; max-width: 100%;"></canvas>
        </div>
    </div>

    <script>
        // Device detection function
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                   window.innerWidth <= 768;
        }
        
        // Global state management
        let currentInputMode = 'text'; // 'text' or 'image'
        let lastUploadedImageSrc = null; // Save last uploaded image data
        
        // 分别保存文字模式和图片模式的设置
        let textModeSettings = {
            height: 10,
            padding: 0
        };
        
        let imageModeSettings = {
            height: 60,
            padding: 0
        };
        
        // 简化的颜色级别：只有黑白两色
        const COLOR_LEVELS = {
            BLACK: 0,
            WHITE: 1
        };
        
        // 图片处理类 - 用于处理图片输入并转换为像素矩阵
        class ImageProcessor {
            constructor() {
                this.threshold = 128; // 二值化阈值
                
                // 5x5 Bayer抖动矩阵（用于灰度处理）
                this.bayerMatrix5x5 = [
                    [ 0, 12,  3, 15,  8],
                    [18,  6, 21,  9, 24],
                    [ 4, 16,  1, 13,  5],
                    [22, 10, 19,  7, 23],
                    [ 2, 14, 11, 20, 17]
                ];
            }
            
            // 加载并处理图片（支持灰度处理模式）
            async loadAndProcessImage(imageSrc, targetHeight, useGrayScale = false) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // 创建canvas来处理图片
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // 计算目标尺寸（保持宽高比）
                            const aspectRatio = img.width / img.height;
                            const targetPixelHeight = targetHeight * 5; // 5x5系统
                            const targetPixelWidth = Math.round(targetPixelHeight * aspectRatio);
                            
                            // 确保尺寸是5的倍数
                            const finalHeight = Math.ceil(targetPixelHeight / 5) * 5;
                            const finalWidth = Math.ceil(targetPixelWidth / 5) * 5;
                            
                            // 设置canvas尺寸并绘制图片
                            canvas.width = finalWidth;
                            canvas.height = finalHeight;
                            ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
                            
                            // 获取图像数据
                            const imageData = ctx.getImageData(0, 0, finalWidth, finalHeight);
                            
                            // 根据模式选择处理方法
                            const processedMatrix = useGrayScale 
                                ? this.applyOrderedDithering(imageData)
                                : this.binarizeImage(imageData);
                            
                            
                            resolve({
                                matrix: processedMatrix,
                                width: finalWidth,
                                height: finalHeight
                            });
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    img.onerror = () => {
                        reject(new Error('图片加载失败'));
                    };
                    
                    img.src = imageSrc;
                });
            }
            
            // 二值化图像数据
            binarizeImage(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const binaryMatrix = [];
                
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        // 计算灰度值
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // 二值化：0=黑色，1=白色
                        row.push(gray < this.threshold ? 0 : 1);
                    }
                    binaryMatrix.push(row);
                }
                
                return binaryMatrix;
            }
            
            // 有序抖动处理（用于灰度模式）
            applyOrderedDithering(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const result = [];
                
                for (let y = 0; y < height; y++) {
                    const row = [];
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        // 计算灰度值
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        
                        // 使用Bayer矩阵确定阈值
                        const matrixSize = 5;
                        const mx = x % matrixSize;
                        const my = y % matrixSize;
                        // 将矩阵值归一化到0-255范围
                        const threshold = (this.bayerMatrix5x5[my][mx] + 1) * 255 / 26;
                        
                        // 根据阈值决定黑白
                        row.push(gray > threshold ? 1 : 0);
                    }
                    result.push(row);
                }
                
                return result;
            }
            
            // 设置二值化阈值
            setThreshold(value) {
                this.threshold = value;
            }
        }
        
        // 横向加强算法M - 模块化实现
        class HorizontalEnhancer {
            constructor() {
                this.adhesionCoefficient = 2; // 默认粘合系数
                this.enableDenoising = true; // 默认启用去噪处理
                this.gapDistanceMap = this.initGapDistanceMap();
                
                // 自身空缺度映射表
                this.selfGapMap = {
                    '🌔': 1,
                    '🌓': 2, 
                    '🌒': 3,
                    '🌑': 4,
                    '🌘': 3,
                    '🌗': 2,
                    '🌖': 1,
                    '🌕': 0
                };
            }
            
            // 设置粘合系数
            setAdhesionCoefficient(coefficient) {
                this.adhesionCoefficient = coefficient;
            }
            
            // 设置去噪开关
            setEnableDenoising(enable) {
                this.enableDenoising = enable;
            }
            
            // 初始化空缺度查找表
            initGapDistanceMap() {
                // 基于算法定义推导的完整空缺度表
                const map = {};
                const moons = ['🌑', '🌘', '🌗', '🌖', '🌕', '🌔', '🌓', '🌒'];
                
                // 🌑与任何字符的空缺度都是-1
                map['🌑'] = {};
                for (const moon of moons) {
                    map['🌑'][moon] = -1;
                }
                
                // 其他月相之间的空缺度
                const distances = {
                    '🌘': { '🌘': 3, '🌗': 3, '🌖': 3, '🌕': 3, '🌔': 4, '🌓': 5, '🌒': 6, '🌑': -1 },
                    '🌗': { '🌘': 2, '🌗': 2, '🌖': 2, '🌕': 2, '🌔': 3, '🌓': 4, '🌒': 5, '🌑': -1 },
                    '🌖': { '🌘': 1, '🌗': 1, '🌖': 1, '🌕': 1, '🌔': 2, '🌓': 3, '🌒': 4, '🌑': -1 },
                    '🌕': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },
                    '🌔': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },
                    '🌓': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 },
                    '🌒': { '🌘': 0, '🌗': 0, '🌖': 0, '🌕': 0, '🌔': 1, '🌓': 2, '🌒': 3, '🌑': -1 }
                };
                
                return { ...map, ...distances };
            }
            
            // 计算两个月相之间的空缺度
            getGapDistance(left, right) {
                return this.gapDistanceMap[left]?.[right] || 0;
            }
            
            // 执行粘合操作 - 根据最少更换原则
            performAdhesion(left, right) {
                const gap = this.getGapDistance(left, right);
                if (gap <= 0 || gap > this.adhesionCoefficient) {
                    return [left, right];
                }
                
                // 尝试各种填充方案，选择更换最少的
                const fillOptions = [
                    ['🌕', right], // 左边变满月
                    [left, '🌕'],  // 右边变满月
                    ['🌕', '🌕']   // 两边都变满月
                ];
                
                // 优先选择只改变一边的方案
                for (const [newLeft, newRight] of fillOptions) {
                    if (this.getGapDistance(newLeft, newRight) === 0) {
                        // 如果只需要改变一边，优先选择
                        if (newLeft !== left && newRight === right) {
                            return [newLeft, newRight];
                        }
                        if (newLeft === left && newRight !== right) {
                            return [newLeft, newRight];
                        }
                    }
                }
                
                // 如果必须改变两边，返回双满月
                return ['🌕', '🌕'];
            }
            
            // 自粘合操作
            selfAdhesion(lines) {
                const processedLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        processedLines.push(line);
                        continue;
                    }
                    
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    for (let i = 0; i < chars.length; i++) {
                        const current = chars[i];
                        
                        // 跳过🌕和🌑
                        if (current === '🌕' || current === '🌑') {
                            continue;
                        }
                        
                        // 检查左右两侧是否都是🌑（空缺度为-1）
                        let leftIsEmpty = false, rightIsEmpty = false;
                        
                        if (i === 0) {
                            leftIsEmpty = true; // 最左侧视为-1
                        } else {
                            leftIsEmpty = (chars[i - 1] === '🌑');
                        }
                        
                        if (i === chars.length - 1) {
                            rightIsEmpty = true; // 最右侧视为-1
                        } else {
                            rightIsEmpty = (chars[i + 1] === '🌑');
                        }
                        
                        // 如果左右两侧都是空缺（-1），执行自粘合检查
                        if (leftIsEmpty && rightIsEmpty) {
                            const selfGap = this.selfGapMap[current] || 0;
                            if (selfGap <= this.adhesionCoefficient) {
                                newChars[i] = '🌕';
                            }
                        }
                    }
                    
                    processedLines.push(newChars.join(''));
                }
                
                return processedLines;
            }
            
            // 主处理函数 - 横向加强
            enhance(moonArtText) {
                if (this.adhesionCoefficient === 0) {
                    return moonArtText;
                }
                
                const lines = moonArtText.split('\n');
                const processedLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        processedLines.push(line);
                        continue;
                    }
                    
                    // 将emoji字符串转换为数组（处理2字节emoji）
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    // 从左到右执行粘合操作
                    for (let i = 0; i < chars.length - 1; i++) {
                        const [newLeft, newRight] = this.performAdhesion(newChars[i], newChars[i + 1]);
                        newChars[i] = newLeft;
                        newChars[i + 1] = newRight;
                    }
                    
                    processedLines.push(newChars.join(''));
                }
                
                // 执行自粘合操作
                const selfAdhesedLines = this.selfAdhesion(processedLines);
                
                // 根据开关决定是否执行去噪操作
                if (this.enableDenoising) {
                    return this.denoise(selfAdhesedLines);
                } else {
                    return selfAdhesedLines.join('\n');
                }
            }
            
            // 去噪操作
            denoise(lines) {
                const denoiseLines = [];
                
                for (let line of lines) {
                    if (line.length === 0) {
                        denoiseLines.push(line);
                        continue;
                    }
                    
                    const chars = Array.from(line);
                    const newChars = [...chars];
                    
                    for (let i = 0; i < chars.length; i++) {
                        const current = chars[i];
                        if (current === '🌑') continue;
                        
                        // 检查左右两侧的空缺度
                        let leftGap = -1, rightGap = -1;
                        
                        if (i > 0) {
                            leftGap = this.getGapDistance(chars[i - 1], current);
                        }
                        if (i < chars.length - 1) {
                            rightGap = this.getGapDistance(current, chars[i + 1]);
                        }
                        
                        // 如果两侧空缺度都满足（大于0或等于-1）且不是🌕，认为是噪点
                        if (current !== '🌕' && 
                            (leftGap > 0 || leftGap === -1) && 
                            (rightGap > 0 || rightGap === -1)) {
                            newChars[i] = '🌑';
                        }
                    }
                    
                    denoiseLines.push(newChars.join(''));
                }
                
                return denoiseLines.join('\n');
            }
        }
        
        class SimpleMoonGenerator {
            constructor() {
                // 基础月相模式：基于黑色像素数量的分布
                this.moonPhases = [
                    { emoji: '🌑', minBlack: 0, maxBlack: 0 },    // 全白/空
                    { emoji: '🌘', minBlack: 1, maxBlack: 4 },    // 很少黑色 
                    { emoji: '🌗', minBlack: 5, maxBlack: 8 },    // 少量黑色
                    { emoji: '🌖', minBlack: 9, maxBlack: 12 },   // 中等黑色
                    { emoji: '🌕', minBlack: 13, maxBlack: 16 }   // 大量黑色
                ];
                
                // 垂直化处理记录：存储被处理字符的位置和密度信息
                this.verticalProcessingPositions = [];
            }
            
            // 最简单的灰度值转换：只有黑白两色
            grayToColorLevel(gray) {
                return gray < 128 ? 0 : 1; // 0 = 黑色，1 = 白色
            }
            
            // 基于5x5网格的新密度分级月相转换系统（带元数据）
            gridToMoonWithMeta(grid) {
                // 统计5x5网格中黑色像素（0）的数量
                let blackCount = 0;
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (grid[y][x] === 0) { // 0 = 黑色
                            blackCount++;
                        }
                    }
                }
                
                // 获取密度等级信息
                const densityLevel = this.getDensityLevel(blackCount);
                
                // 计算水平重心和偏向
                const centerX = this.calculateHorizontalCenter(grid);
                const bias = this.getBias(centerX);
                
                // 根据密度等级和偏向选择原始月相
                let originalMoonPhase;
                switch (densityLevel.name) {
                    case '极低密度':
                        originalMoonPhase = '🌑';
                        break;
                    case '高密度':
                        originalMoonPhase = '🌕';
                        break;
                    case '中低密度':
                    case '中等密度':
                    case '次高密度':
                        originalMoonPhase = this.selectMoonPhase(densityLevel.name, bias);
                        break;
                    default:
                        originalMoonPhase = '🌑';
                }
                
                // 返回完整的元数据
                return {
                    originalMoonPhase: originalMoonPhase,
                    finalMoonPhase: originalMoonPhase, // 初始时与原始月相相同
                    densityLevel: densityLevel.name,
                    densitySymbol: densityLevel.debugSymbol,
                    bias: bias,
                    blackCount: blackCount,
                    centerX: centerX
                };
            }
            
            // 基于5x5网格的新密度分级月相转换系统（向后兼容）
            gridToMoon(grid) {
                return this.gridToMoonWithMeta(grid).finalMoonPhase;
            }
            
            // 获取密度等级
            getDensityLevel(blackCount) {
                const densityLevels = [
                    { name: '极低密度', minPixels: 1, maxPixels: 4, debugSymbol: '⬛' },
                    { name: '中低密度', minPixels: 5, maxPixels: 8, debugSymbol: '🟦' },
                    { name: '中等密度', minPixels: 9, maxPixels: 14, debugSymbol: '🟧' },
                    { name: '次高密度', minPixels: 15, maxPixels: 21, debugSymbol: '🟨' },
                    { name: '高密度', minPixels: 22, maxPixels: 25, debugSymbol: '无' }
                ];
                
                if (blackCount === 0) {
                    return { name: '空白', debugSymbol: '⬜' };
                }
                
                for (const level of densityLevels) {
                    if (blackCount >= level.minPixels && blackCount <= level.maxPixels) {
                        return level;
                    }
                }
                
                // 超出范围，默认为高密度
                return densityLevels[4];
            }
            
            // 计算5x5网格的水平重心
            calculateHorizontalCenter(grid) {
                let weightedX = 0;
                let totalBlack = 0;
                
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (grid[y][x] === 0) { // 0 = 黑色
                            weightedX += x;
                            totalBlack++;
                        }
                    }
                }
                
                return totalBlack > 0 ? weightedX / totalBlack : 2; // 5x5中心为2
            }
            
            // 判断重心偏向
            getBias(centerX) {
                if (centerX < 1.8) {
                    return 'left';
                } else if (centerX > 2.2) {
                    return 'right';
                } else {
                    return 'balanced';
                }
            }
            
            // 根据密度等级和偏向选择月相
            selectMoonPhase(densityLevel, bias) {
                const phaseMap = {
                    '中低密度': { left: '🌘', right: '🌒', balanced: '🌕' },
                    '中等密度': { left: '🌗', right: '🌓', balanced: '🌕' },
                    '次高密度': { left: '🌖', right: '🌔', balanced: '🌕' }
                };
                
                return phaseMap[densityLevel]?.[bias] || '🌕';
            }
            
            // 月相反色处理
            reverseMoon(emoji) {
                const reverseMap = {
                    '🌑': '🌕', // 新月 ↔ 满月
                    '🌒': '🌖', // 蛾月 ↔ 亏月
                    '🌓': '🌗', // 上弦月 ↔ 下弦月
                    '🌔': '🌘', // 凸月 ↔ 残月
                    '🌕': '🌑', // 满月 ↔ 新月
                    '🌖': '🌒', // 亏月 ↔ 蛾月
                    '🌗': '🌓', // 下弦月 ↔ 上弦月
                    '🌘': '🌔'  // 残月 ↔ 凸月
                };
                return reverseMap[emoji] || emoji;
            }
            
            // 垂直化处理：字符空缺度映射表
            getCharacterVacancy(moonPhase) {
                // 增强的字符规范化处理
                let normalizedPhase = moonPhase.normalize('NFC').replace(/[\uFE0E\uFE0F]/g, '').trim();
                
                // 使用字符码点进行精确匹配
                const vacancyMapByCodePoint = {
                    0x1F314: 1, // 🌔
                    0x1F313: 2, // 🌓  
                    0x1F312: 3, // 🌒
                    0x1F311: 4, // 🌑
                    0x1F318: 3, // 🌘
                    0x1F317: 2, // 🌗
                    0x1F316: 1, // 🌖
                    0x1F315: 0  // 🌕
                };
                
                // 优先使用码点匹配
                const codePoint = normalizedPhase.codePointAt(0);
                if (codePoint && vacancyMapByCodePoint.hasOwnProperty(codePoint)) {
                    return vacancyMapByCodePoint[codePoint];
                }
                
                // 备用字符串匹配
                const vacancyMap = {
                    '🌔': 1, '🌓': 2, '🌒': 3, '🌑': 4,
                    '🌘': 3, '🌗': 2, '🌖': 1, '🌕': 0
                };
                
                return vacancyMap[normalizedPhase] || 4; // 默认为最高空缺度
            }
            
            // 检查是否需要垂直化处理
            shouldApplyVerticalProcessing(cellMeta, targetDensityLevels) {
                return targetDensityLevels.includes(cellMeta.densityLevel) && 
                       cellMeta.bias === 'balanced';
            }
            
            // 从上到下进行垂直化处理
            applyVerticalProcessing(gridWithMeta, targetDensityLevels, thresholdN = 2) {
                const gridHeight = gridWithMeta.length;
                const gridWidth = gridWithMeta[0]?.length || 0;
                
                // 清空之前的记录
                this.verticalProcessingPositions = [];
                
                
                
                
                
                // 从第2行开始处理（第1行没有上方字符）
                for (let row = 1; row < gridHeight; row++) {
                    for (let col = 0; col < gridWidth; col++) {
                        const currentCell = gridWithMeta[row][col];
                        
                        
                        // 检查是否需要垂直化处理
                        if (this.shouldApplyVerticalProcessing(currentCell, targetDensityLevels)) {
                            
                            
                            // 记录被垂直化处理的位置和密度信息
                            this.verticalProcessingPositions.push({
                                row: row,
                                col: col,
                                densityLevel: currentCell.densityLevel
                            });
                            
                            const aboveCell = gridWithMeta[row - 1][col];
                            const aboveVacancy = this.getCharacterVacancy(aboveCell.finalMoonPhase);
                            
                            
                            // 统一使用空缺度判断
                            if (aboveVacancy <= thresholdN) {
                                currentCell.finalMoonPhase = '🌑';
                            } else {
                                currentCell.finalMoonPhase = '🌕';
                            }
                            
                        }
                        // 不需要垂直化处理的字符保持原有finalMoonPhase不变
                    }
                }
                
                
                return gridWithMeta;
            }
            
            // 密度等级调试符号映射
            getDensityDebugSymbol(densityLevel) {
                const DENSITY_DEBUG_SYMBOLS = {
                    '中等密度': '🟧',  // 橙色方块
                    '中低密度': '🟦',  // 蓝色方块  
                    '次高密度': '🟨',  // 黄色方块
                    '极低密度': '⬛',  // 黑色方块
                    '高密度': '🌕'     // 保持原样
                };
                
                return DENSITY_DEBUG_SYMBOLS[densityLevel] || '❓';
            }
            
            
            // 应用字符间距
            applySpacing(text, spacing) {
                if (spacing <= 0) return text;
                
                const lines = text.split('\n');
                const spacedLines = [];
                
                for (const line of lines) {
                    if (line.length === 0) {
                        spacedLines.push(line);
                        continue;
                    }
                    
                    // 在每个字符之间插入指定数量的🌑（空格）
                    const chars = Array.from(line);
                    const spacedChars = [];
                    
                    for (let i = 0; i < chars.length; i++) {
                        spacedChars.push(chars[i]);
                        // 除了最后一个字符，每个字符后面都添加间距
                        if (i < chars.length - 1) {
                            spacedChars.push('🌑'.repeat(spacing));
                        }
                    }
                    
                    spacedLines.push(spacedChars.join(''));
                }
                
                return spacedLines.join('\n');
            }
            
            // 应用边距（padding）
            applyPadding(text, padding) {
                if (padding <= 0) return text;
                
                const lines = text.split('\n');
                if (lines.length === 0) return text;
                
                // 计算最大行宽
                const maxWidth = Math.max(...lines.map(line => Array.from(line).length));
                
                // 创建边距字符（黑月）
                const paddingChar = '🌑';
                const horizontalPadding = paddingChar.repeat(padding);
                const fullPaddingLine = paddingChar.repeat(maxWidth + 2 * padding);
                
                const paddedLines = [];
                
                // 添加上边距
                for (let i = 0; i < padding; i++) {
                    paddedLines.push(fullPaddingLine);
                }
                
                // 添加左右边距到每一行
                for (const line of lines) {
                    const chars = Array.from(line);
                    // 填充行到最大宽度
                    while (chars.length < maxWidth) {
                        chars.push('🌑');
                    }
                    const paddedLine = horizontalPadding + chars.join('') + horizontalPadding;
                    paddedLines.push(paddedLine);
                }
                
                // 添加下边距
                for (let i = 0; i < padding; i++) {
                    paddedLines.push(fullPaddingLine);
                }
                
                return paddedLines.join('\n');
            }
            
            // 从像素矩阵生成月文字（用于图片输入）
            generateFromPixelMatrix(pixelMatrix, width, height, enableVerticalProcessing = true, padding = 0) {
                
                // 清空垂直化处理记录
                this.verticalProcessingPositions = [];
                
                // 创建元数据网格
                const metaGrid = [];
                const gridSize = 5;
                
                // 按5x5网格扫描像素矩阵
                for (let y = 0; y < height; y += gridSize) {
                    const metaRow = [];
                    for (let x = 0; x < width; x += gridSize) {
                        // 提取5x5子网格
                        const subGrid = [];
                        for (let dy = 0; dy < gridSize; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < gridSize; dx++) {
                                const py = y + dy;
                                const px = x + dx;
                                // 边界检查
                                if (py < height && px < width) {
                                    subGrid[dy][dx] = pixelMatrix[py][px];
                                } else {
                                    subGrid[dy][dx] = 1; // 超出边界默认为白色
                                }
                            }
                        }
                        
                        // 将5x5网格转换为带元数据的月相
                        const cellMeta = this.gridToMoonWithMeta(subGrid);
                        metaRow.push(cellMeta);
                    }
                    if (metaRow.length > 0) {
                        metaGrid.push(metaRow);
                    }
                }
                
                
                // 应用垂直化处理（如果启用）
                if (enableVerticalProcessing) {
                    // 从UI获取垂直化处理设置
                    const targetDensityLevels = [];
                    if (document.getElementById('verticalMedium').checked) {
                        targetDensityLevels.push('中等密度');
                    }
                    if (document.getElementById('verticalHigh').checked) {
                        targetDensityLevels.push('次高密度');
                    }
                    const thresholdN = 2; // 默认阈值
                    
                    this.applyVerticalProcessing(metaGrid, targetDensityLevels, thresholdN);
                }
                
                // 从元数据网格提取最终月相
                const resultLines = metaGrid.map(row => 
                    row.map(cell => cell.finalMoonPhase).join('')
                );
                
                let result = resultLines.join('\n');
                
                
                // 应用边距
                if (padding > 0) {
                    result = this.applyPadding(result, padding);
                }
                
                return result;
            }
            
            // 专门用于图片的简化处理流程（跳过文字优化算法）
            generateFromImage(pixelMatrix, width, height, padding = 0) {
                
                const metaGrid = [];
                const gridSize = 5;
                
                // 按5x5网格扫描像素矩阵
                for (let y = 0; y < height; y += gridSize) {
                    const metaRow = [];
                    for (let x = 0; x < width; x += gridSize) {
                        // 提取5x5子网格
                        const subGrid = [];
                        for (let dy = 0; dy < gridSize; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < gridSize; dx++) {
                                const py = y + dy;
                                const px = x + dx;
                                if (py < height && px < width) {
                                    subGrid[dy][dx] = pixelMatrix[py][px];
                                } else {
                                    subGrid[dy][dx] = 1; // 超出边界默认为白色
                                }
                            }
                        }
                        
                        // 直接转换为月相（使用专门的图片映射逻辑）
                        const moonPhase = this.gridToMoonForImage(subGrid);
                        metaRow.push(moonPhase);
                    }
                    if (metaRow.length > 0) {
                        metaGrid.push(metaRow);
                    }
                }
                
                // 直接生成结果字符串
                const resultLines = metaGrid.map(row => row.join(''));
                let result = resultLines.join('\n');
                
                // 仅应用边距（如果需要）
                if (padding > 0) {
                    result = this.applyPadding(result, padding);
                }
                
                return result;
            }
            
            // 专门用于图片的5x5网格到月相映射（8级灰度）
            gridToMoonForImage(grid) {
                // 统计黑色像素数量
                let blackCount = 0;
                for (let y = 0; y < 5; y++) {
                    for (let x = 0; x < 5; x++) {
                        if (grid[y][x] === 0) {
                            blackCount++;
                        }
                    }
                }
                
                // 更精细的灰度级别映射（8个月相对应不同密度）
                // 0-25个黑点映射到月相
                const ratio = blackCount / 25;
                
                // 根据黑色像素比例返回对应月相
                // 注意：这里的映射是基于视觉密度，黑色越多月相越"满"
                if (ratio === 0) return '🌑';        // 0% - 全白背景
                else if (ratio <= 0.125) return '🌘'; // 0-12.5% - 极少黑色
                else if (ratio <= 0.25) return '🌗';  // 12.5-25% - 少量黑色
                else if (ratio <= 0.375) return '🌖'; // 25-37.5% - 较少黑色
                else if (ratio <= 0.5) return '🌕';   // 37.5-50% - 中等黑色
                else if (ratio <= 0.625) return '🌔'; // 50-62.5% - 较多黑色
                else if (ratio <= 0.75) return '🌓';  // 62.5-75% - 大量黑色
                else if (ratio <= 0.875) return '🌒'; // 75-87.5% - 极多黑色
                else return '🌑';                     // 87.5-100% - 几乎全黑
            }
            
            // 生成单个字符的月相
            generateSingleChar(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
                if (!char.trim()) return [];
                
                const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
                
                // 第一阶段：创建足够大的canvas来完整渲染字符
                const baseFontSize = Math.max(sizeParam * 5, 50); // 确保字符足够大（5x5系统）
                const canvasWidth = baseFontSize * 2;   // 给字符足够的宽度空间
                const canvasHeight = baseFontSize * 2;  // 给字符足够的高度空间
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                const ctx = canvas.getContext('2d');
                
                // 绘制白色背景
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制黑色字符
                ctx.fillStyle = 'black';
                ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const x = canvas.width / 2;
                const y = canvas.height / 2;
                ctx.fillText(char, x, y);
                
                
                // 获取图像数据并转换为像素矩阵
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixelMatrix = [];
                
                for (let y = 0; y < canvas.height; y++) {
                    pixelMatrix[y] = [];
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        const gray = 0.299 * imageData.data[idx] + 
                                   0.587 * imageData.data[idx + 1] + 
                                   0.114 * imageData.data[idx + 2];
                        pixelMatrix[y][x] = this.grayToColorLevel(gray);
                    }
                }
                
                // 找到字符的实际边界
                let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
                let foundText = false;
                
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if (pixelMatrix[y][x] === 0) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            foundText = true;
                        }
                    }
                }
                
                if (!foundText) {
                    // 如果没找到文字，返回按目标尺寸的默认矩形
                    if (isVertical) {
                        // 竖向：固定宽度sizeParam，默认高度3
                        const defaultLine = '🌕'.repeat(sizeParam);
                        return [defaultLine, defaultLine, defaultLine];
                    } else {
                        // 横向：固定高度sizeParam，默认宽度3
                        const result = [];
                        for (let i = 0; i < sizeParam; i++) {
                            result.push('🌕🌕🌕');
                        }
                        return result;
                    }
                }
                
                // 第二阶段：将字符边界映射到目标尺寸
                const charWidth = maxX - minX + 1;
                const charHeight = maxY - minY + 1;
                
                let targetPixelWidth, targetPixelHeight;
                if (isVertical) {
                    // 竖向：固定宽度为sizeParam*5像素，高度按比例缩放（5x5系统）
                    targetPixelWidth = sizeParam * 5;
                    targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
                    // 确保高度是5的倍数
                    targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
                } else {
                    // 横向：固定高度为sizeParam*5像素，宽度按比例缩放（5x5系统）
                    targetPixelHeight = sizeParam * 5;
                    targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
                    // 确保宽度是5的倍数
                    targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
                }
                
                
                // 第三阶段：按目标尺寸进行5x5网格扫描
                const gridSize = 5;
                const resultLines = [];
                
                for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
                    let line = '';
                    for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
                        // 提取5x5子网格
                        const subGrid = [];
                        for (let dy = 0; dy < 5; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < 5; dx++) {
                                // 将目标坐标映射回原始字符坐标
                                const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
                                const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
                                
                                if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
                                    subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
                                } else {
                                    subGrid[dy][dx] = 1; // 白色
                                }
                            }
                        }
                        
                        line += this.gridToMoon(subGrid);
                    }
                    resultLines.push(line);
                }
                
                
                return resultLines;
            }
            
            // 垂直拼接字符结果（竖向排版）- 字符从上到下排列
            combineVertically(charResults, spacing, sizeParam) {
                if (charResults.length === 0) return '';
                
                let combinedLines = [];
                
                for (let i = 0; i < charResults.length; i++) {
                    const charLines = charResults[i];
                    
                    // 添加当前字符的所有行
                    combinedLines.push(...charLines);
                    
                    // 如果不是最后一个字符，添加间距行（水平分隔）
                    if (i < charResults.length - 1 && spacing > 0) {
                        // 使用目标宽度sizeParam作为间距行宽度，确保与字符宽度一致
                        const spacingLine = '🌑'.repeat(sizeParam || 10);
                        
                        // 添加指定数量的间距行
                        for (let j = 0; j < spacing; j++) {
                            combinedLines.push(spacingLine);
                        }
                    }
                }
                
                return combinedLines.join('\n');
            }
            
            // 水平拼接字符结果（横向排版）
            combineHorizontally(charResults, spacing, sizeParam) {
                if (charResults.length === 0) return '';
                
                // 找出最大行数，确保所有字符结果对齐
                const maxLines = Math.max(...charResults.map(result => result.length));
                
                // 标准化所有字符结果，确保行数相等
                const normalizedResults = charResults.map(result => {
                    const normalized = [...result];
                    // 横向排版时，使用目标宽度sizeParam确保填充行宽度一致
                    const emptyLine = '🌑'.repeat(sizeParam || 10);
                    
                    // 用空行填充到最大行数
                    while (normalized.length < maxLines) {
                        normalized.push(emptyLine);
                    }
                    
                    return normalized;
                });
                
                const finalLines = [];
                
                // 逐行拼接
                for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
                    let combinedLine = '';
                    
                    for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
                        combinedLine += normalizedResults[charIndex][lineIndex];
                        
                        // 如果不是最后一个字符，添加间距列
                        if (charIndex < normalizedResults.length - 1 && spacing > 0) {
                            combinedLine += '🌑'.repeat(spacing);
                        }
                    }
                    
                    finalLines.push(combinedLine);
                }
                
                return finalLines.join('\n');
            }
            
            // 生成带元数据的单个字符
            generateSingleCharWithMeta(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
                if (!char.trim()) return [];
                
                const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
                
                // 第一阶段：创建足够大的canvas来完整渲染字符
                const baseFontSize = Math.max(sizeParam * 5, 50);
                const canvasWidth = baseFontSize * 2;
                const canvasHeight = baseFontSize * 2;
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                const ctx = canvas.getContext('2d');
                
                // 绘制白色背景
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制黑色字符
                ctx.fillStyle = 'black';
                ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const x = canvas.width / 2;
                const y = canvas.height / 2;
                ctx.fillText(char, x, y);
                
                
                // 获取图像数据并转换为像素矩阵
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixelMatrix = [];
                
                for (let y = 0; y < canvas.height; y++) {
                    pixelMatrix[y] = [];
                    for (let x = 0; x < canvas.width; x++) {
                        const idx = (y * canvas.width + x) * 4;
                        const gray = 0.299 * imageData.data[idx] + 
                                   0.587 * imageData.data[idx + 1] + 
                                   0.114 * imageData.data[idx + 2];
                        pixelMatrix[y][x] = this.grayToColorLevel(gray);
                    }
                }
                
                // 找到字符的实际边界
                let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
                let foundText = false;
                
                for (let y = 0; y < canvas.height; y++) {
                    for (let x = 0; x < canvas.width; x++) {
                        if (pixelMatrix[y][x] === 0) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            foundText = true;
                        }
                    }
                }
                
                if (!foundText) {
                    // 如果没找到文字，返回按目标尺寸的默认矩形元数据
                    const defaultSize = isVertical ? [sizeParam, 3] : [3, sizeParam];
                    const defaultGrid = [];
                    for (let row = 0; row < defaultSize[1]; row++) {
                        defaultGrid[row] = [];
                        for (let col = 0; col < defaultSize[0]; col++) {
                            defaultGrid[row][col] = this.gridToMoonWithMeta(Array(5).fill().map(() => Array(5).fill(0)));
                        }
                    }
                    return defaultGrid;
                }
                
                // 第二阶段：将字符边界映射到目标尺寸
                const charWidth = maxX - minX + 1;
                const charHeight = maxY - minY + 1;
                
                let targetPixelWidth, targetPixelHeight;
                if (isVertical) {
                    targetPixelWidth = sizeParam * 5;
                    targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
                    targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
                } else {
                    targetPixelHeight = sizeParam * 5;
                    targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
                    targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
                }
                
                
                // 第三阶段：按目标尺寸进行5x5网格扫描并生成元数据
                const gridSize = 5;
                const metaGrid = [];
                
                for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
                    const metaRow = [];
                    for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
                        // 提取5x5子网格
                        const subGrid = [];
                        for (let dy = 0; dy < 5; dy++) {
                            subGrid[dy] = [];
                            for (let dx = 0; dx < 5; dx++) {
                                const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
                                const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
                                
                                if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
                                    subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
                                } else {
                                    subGrid[dy][dx] = 1; // 白色
                                }
                            }
                        }
                        
                        metaRow.push(this.gridToMoonWithMeta(subGrid));
                    }
                    metaGrid.push(metaRow);
                }
                
                
                return metaGrid;
            }

            // 生成月文字（使用单字符处理架构，支持垂直化处理）
            generate(text, sizeParam = 20, fontType = 'custom', isVertical = true, reverseColor = false, spacing = 0, enableVerticalProcessing = true, padding = 0) {
                if (!text.trim()) return '';
                
                
                // 将文本拆分为字符数组
                const chars = Array.from(text);
                
                if (enableVerticalProcessing) {
                    // 为每个字符生成带元数据的结果
                    const charMetaResults = chars.map(char => {
                        return this.generateSingleCharWithMeta(char, sizeParam, fontType, isVertical);
                    });
                    
                    // 创建全局元数据网格用于垂直化处理
                    let globalMetaGrid = [];
                    let maxCharWidth = 0;
                    
                    if (isVertical) {
                        // 竖向排版：字符从上到下排列
                        for (let charIndex = 0; charIndex < charMetaResults.length; charIndex++) {
                            const charMeta = charMetaResults[charIndex];
                            maxCharWidth = Math.max(maxCharWidth, charMeta[0]?.length || 0);
                            
                            // 添加当前字符的所有行到全局网格
                            globalMetaGrid.push(...charMeta);
                            
                            // 如果不是最后一个字符且需要间距，添加间距行
                            if (charIndex < charMetaResults.length - 1 && spacing > 0) {
                                for (let s = 0; s < spacing; s++) {
                                    const spacingRow = [];
                                    for (let col = 0; col < (charMeta[0]?.length || sizeParam); col++) {
                                        spacingRow.push({
                                            originalMoonPhase: '🌑',
                                            finalMoonPhase: '🌑',
                                            densityLevel: '极低密度',
                                            densitySymbol: '⬛',
                                            bias: 'balanced',
                                            blackCount: 0,
                                            centerX: 2
                                        });
                                    }
                                    globalMetaGrid.push(spacingRow);
                                }
                            }
                        }
                    } else {
                        // 横向排版：字符从左到右排列
                        const maxLines = Math.max(...charMetaResults.map(result => result.length));
                        
                        // 标准化所有字符结果的行数
                        const normalizedResults = charMetaResults.map(result => {
                            const normalized = [...result];
                            const charWidth = result[0]?.length || sizeParam;
                            
                            while (normalized.length < maxLines) {
                                const emptyRow = [];
                                for (let col = 0; col < charWidth; col++) {
                                    emptyRow.push({
                                        originalMoonPhase: '🌑',
                                        finalMoonPhase: '🌑',
                                        densityLevel: '极低密度',
                                        densitySymbol: '⬛',
                                        bias: 'balanced',
                                        blackCount: 0,
                                        centerX: 2
                                    });
                                }
                                normalized.push(emptyRow);
                            }
                            
                            return normalized;
                        });
                        
                        // 逐行拼接所有字符
                        for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
                            const combinedRow = [];
                            
                            for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
                                combinedRow.push(...normalizedResults[charIndex][lineIndex]);
                                
                                // 如果不是最后一个字符且需要间距，添加间距列
                                if (charIndex < normalizedResults.length - 1 && spacing > 0) {
                                    for (let s = 0; s < spacing; s++) {
                                        combinedRow.push({
                                            originalMoonPhase: '🌑',
                                            finalMoonPhase: '🌑',
                                            densityLevel: '极低密度',
                                            densitySymbol: '⬛',
                                            bias: 'balanced',
                                            blackCount: 0,
                                            centerX: 2
                                        });
                                    }
                                }
                            }
                            
                            globalMetaGrid.push(combinedRow);
                        }
                    }
                    
                    
                    // 从UI获取垂直化处理设置
                    const targetDensityLevels = [];
                    if (document.getElementById('verticalMedium') && document.getElementById('verticalMedium').checked) {
                        targetDensityLevels.push('中等密度');
                    }
                    if (document.getElementById('verticalHigh') && document.getElementById('verticalHigh').checked) {
                        targetDensityLevels.push('次高密度');
                    }
                    const thresholdN = 2; // 默认阈值
                    
                    globalMetaGrid = this.applyVerticalProcessing(globalMetaGrid, targetDensityLevels, thresholdN);
                    
                    // 验证垂直化处理的结果
                    console.error(`🔍 验证垂直化处理结果:`);
                    let avoidCount = 0, keepCount = 0;
                    this.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < globalMetaGrid.length && pos.col < globalMetaGrid[pos.row].length) {
                            const cell = globalMetaGrid[pos.row][pos.col];
                            console.error(`验证位置(${pos.row},${pos.col}): finalMoonPhase=${cell.finalMoonPhase}, 密度=${cell.densityLevel}`);
                            if (cell.finalMoonPhase === '🌑') {
                                avoidCount++;
                            } else if (cell.finalMoonPhase === '🌕') {
                                keepCount++;
                            }
                        }
                    });
                    console.error(`📊 垂直化处理统计: 避让🌑=${avoidCount}个, 保持🌕=${keepCount}个`);
                    
                    // 从处理后的元数据网格提取最终月相
                    const resultLines = globalMetaGrid.map(row => 
                        row.map(cell => cell.finalMoonPhase).join('')
                    );
                    
                    let result = resultLines.join('\n');
                    
                    
                    console.log(`垂直化处理完成，字符数: ${chars.length}, 结果行数: ${result.split('\n').length}`);
                    
                    // 应用边距
                    if (padding > 0) {
                        result = this.applyPadding(result, padding);
                        console.log(`边距应用完成，边距宽度: ${padding}`);
                    }
                    
                    return result;
                    
                } else {
                    // 传统处理方式（无垂直化）
                    const charResults = chars.map(char => {
                        return this.generateSingleChar(char, sizeParam, fontType, isVertical);
                    });
                    
                    // 根据排版方向拼接结果
                    let result;
                    if (isVertical) {
                        result = this.combineVertically(charResults, spacing, sizeParam);
                    } else {
                        result = this.combineHorizontally(charResults, spacing, sizeParam);
                    }
                    
                    console.log(`单字符生成完成，字符数: ${chars.length}, 结果行数: ${result.split('\n').length}`);
                    
                    // 应用边距
                    if (padding > 0) {
                        result = this.applyPadding(result, padding);
                        console.log(`边距应用完成，边距宽度: ${padding}`);
                    }
                    
                    return result;
                }
            }
        }
        
        // 字体映射
        const FONT_FAMILIES = {
            'default': 'sans-serif',
            'monospace': 'monospace',
            'sans-serif': 'sans-serif',
            'serif': 'serif'
        };

        // 字体预设配置：粘合系数和垂直化处理密度级别
        const FONT_CONFIGS = {
            'default': { 
                adhesionCoefficient: 2,
                verticalDensityLevels: ['中等密度', '次高密度']
            },
            'monospace': { 
                adhesionCoefficient: 2,
                verticalDensityLevels: ['中等密度', '次高密度']
            },
            'sans-serif': { 
                adhesionCoefficient: 3,
                verticalDensityLevels: []  // 不使用垂直化处理
            },
            'serif': { 
                adhesionCoefficient: 2,
                verticalDensityLevels: ['中等密度', '次高密度']
            }
        };
        
        // 初始化
        const generator = new SimpleMoonGenerator();
        const horizontalEnhancer = new HorizontalEnhancer();
        
        // Copy to clipboard function
        function copyToClipboard() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('Generated result will appear here')) return;
            
            navigator.clipboard.writeText(moonArt).then(() => {
                const copyBtn = document.getElementById('copyBtn');
                const btnText = copyBtn.querySelector('.btn-text');
                const originalText = btnText.textContent;
                
                btnText.textContent = 'Copied!';
                copyBtn.classList.add('success');
                
                setTimeout(() => {
                    btnText.textContent = originalText;
                    copyBtn.classList.remove('success');
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }
        
        // Text download function
        function downloadText() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('Generated result will appear here')) return;
            
            const randomId = Math.random().toString(36).substring(2, 8);
            const filename = `moon-art-${randomId}-${Date.now()}.txt`;
            
            const blob = new Blob([moonArt], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
        }
        
        // Image download function
        function downloadImage() {
            const moonArt = document.getElementById('moonArt').textContent;
            if (!moonArt || moonArt.includes('Generated result will appear here')) return;
            
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const lines = moonArt.split('\n');
            const fontSize = 20;
            const lineHeight = fontSize;
            
            // Calculate canvas size
            canvas.width = lines[0].length * fontSize / 2;
            canvas.height = lines.length * lineHeight;
            
            // Draw moon art (transparent background)
            ctx.fillStyle = 'black';
            ctx.font = `${fontSize}px sans-serif`;
            ctx.textBaseline = 'top';
            
            lines.forEach((line, lineIndex) => {
                let x = 0;
                for (let i = 0; i < line.length; i += 2) {
                    const emoji = line.substr(i, 2);
                    ctx.fillText(emoji, x, lineIndex * lineHeight);
                    x += fontSize;
                }
            });
            
            // Download image
            const randomId = Math.random().toString(36).substring(2, 8);
            const filename = `moon-art-${randomId}-${Date.now()}.png`;
            
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
        
        // Unified preview update function (calls appropriate processing function based on current mode)
        function updatePreview() {
            console.log(`updatePreview - Current mode: ${currentInputMode}`);
            
            // Decide processing method based on current mode
            if (currentInputMode === 'image' && lastUploadedImageSrc) {
                // Image mode: regenerate image moon art
                console.log('Updating image preview');
                generateFromImage(lastUploadedImageSrc);
            } else if (currentInputMode === 'text') {
                // Text mode: execute original text processing logic
                console.log('Updating text preview');
                updateTextPreview();
            } else {
                // No content, show prompt
                document.getElementById('moonArt').textContent = '<!-- Generated result will appear here -->';
                document.getElementById('actionButtons').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
            }
        }
        
        // Text mode preview update
        function updateTextPreview() {
            const text = document.getElementById('textInput').value.trim();
            const sizeValue = parseInt(document.getElementById('heightSlider').value);
            const fontType = document.querySelector('input[name="fontType"]:checked')?.value || 'monospace';
            const adhesionCoefficient = 2; // Fixed value for English version
            const spacing = parseInt(document.getElementById('spacingSlider').value);
            const padding = parseInt(document.getElementById('paddingSlider').value);
            
            const selectedRadio = document.querySelector('input[name="direction"]:checked');
            console.log('updatePreview - Selected radio button:', selectedRadio);
            console.log('updatePreview - Selected value:', selectedRadio?.value);
            const isVertical = selectedRadio?.value === 'vertical';
            console.log('updatePreview - Final isVertical value:', isVertical);
            
            const reverseColor = document.getElementById('reverseColor').checked;
            const enableDenoising = document.getElementById('enableDenoising')?.checked || true;
            
            if (!text) {
                document.getElementById('moonArt').textContent = '<!-- Generated result will appear here -->';
                document.getElementById('actionButtons').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
                return;
            }
            
            try {
                // Generate basic result (enable vertical processing, no color reversal)
                let result = generator.generate(text, sizeValue, fontType, isVertical, false, spacing, true, padding);
                
                // Add debug output after vertical processing
                console.log(`🔄 Vertical processing complete, preparing for horizontal enhancement algorithm`);
                console.log(`Vertical processing record count: ${generator.verticalProcessingPositions.length}`);
                if (generator.verticalProcessingPositions.length > 0) {
                    console.log(`Vertical processing details:`, generator.verticalProcessingPositions);
                    const lines = result.split('\n');
                    generator.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < lines.length && pos.col < lines[pos.row].length) {
                            const char = Array.from(lines[pos.row])[pos.col];
                            console.log(`Position(${pos.row},${pos.col}): Current character=${char}, Density=${pos.densityLevel}`);
                        }
                    });
                }
                
                // Apply horizontal enhancement algorithm
                horizontalEnhancer.setAdhesionCoefficient(adhesionCoefficient);
                horizontalEnhancer.setEnableDenoising(enableDenoising);
                result = horizontalEnhancer.enhance(result);
                
                
                // Final result check for vertical processing
                console.log(`🔍 Vertical processing final result check (no horizontal interference)`);
                if (generator.verticalProcessingPositions.length > 0) {
                    const linesFinal = result.split('\n');
                    let moon_count = 0, black_count = 0;
                    
                    generator.verticalProcessingPositions.forEach(pos => {
                        if (pos.row < linesFinal.length && pos.col < linesFinal[pos.row].length) {
                            const charFinal = Array.from(linesFinal[pos.row])[pos.col];
                            console.log(`Final position(${pos.row},${pos.col}): Character=${charFinal}, Density=${pos.densityLevel}`);
                            
                            if (charFinal === '🌕') moon_count++;
                            else if (charFinal === '🌑') black_count++;
                        }
                    });
                    
                    console.error(`📊 Vertical processing statistics: 🌕=${moon_count}, 🌑=${black_count}`);
                    
                    // Check entire result string content statistics
                    const allChars = result.replace(/\n/g, '');
                    const totalMoon = (allChars.match(/🌕/g) || []).length;
                    const totalBlack = (allChars.match(/🌑/g) || []).length;
                    console.error(`📊 Overall character statistics: Total🌕=${totalMoon}, Total🌑=${totalBlack}`);
                }
                
                // Finally execute color reversal
                if (reverseColor) {
                    result = Array.from(result).map(char => {
                        if (char === '\n') return char;
                        return generator.reverseMoon(char);
                    }).join('');
                }
                
                document.getElementById('moonArt').textContent = result;
                
                
                // Show action buttons
                document.getElementById('actionButtons').style.display = 'flex';
                
                    
            } catch (error) {
                console.error('Generation error:', error);
                document.getElementById('moonArt').textContent = 'Error occurred';
                document.getElementById('actionButtons').style.display = 'none';
                document.getElementById('debugInfo').style.display = 'none';
            }
        }
        
        // Check if mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
                   window.innerWidth <= 768;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const heightSlider = document.getElementById('heightSlider');
            const heightValue = document.getElementById('heightValue');
            const spacingSlider = document.getElementById('spacingSlider');
            const spacingValue = document.getElementById('spacingValue');
            const paddingSlider = document.getElementById('paddingSlider');
            const paddingValue = document.getElementById('paddingValue');
            
            // Height slider for text tab
            heightSlider.addEventListener('input', () => {
                heightValue.textContent = heightSlider.value;
                
                // Update corresponding mode settings
                if (currentInputMode === 'text') {
                    textModeSettings.height = parseInt(heightSlider.value);
                } else {
                    imageModeSettings.height = parseInt(heightSlider.value);
                }
                
                updatePreview();
            });
            
            // Image height slider
            const imageHeightSlider = document.getElementById('imageHeightSlider');
            const imageHeightValue = document.getElementById('imageHeightValue');
            
            imageHeightSlider.addEventListener('input', () => {
                imageHeightValue.textContent = imageHeightSlider.value;
                imageModeSettings.height = parseInt(imageHeightSlider.value);
                updatePreview();
            });
            
            // Spacing slider
            spacingSlider.addEventListener('input', () => {
                spacingValue.textContent = spacingSlider.value;
                updatePreview();
            });
            
            // Padding slider
            paddingSlider.addEventListener('input', () => {
                paddingValue.textContent = paddingSlider.value;
                
                // Update corresponding mode settings
                if (currentInputMode === 'text') {
                    textModeSettings.padding = parseInt(paddingSlider.value);
                } else {
                    imageModeSettings.padding = parseInt(paddingSlider.value);
                }
                
                updatePreview();
            });
            
            // Image padding slider
            const imagePaddingSlider = document.getElementById('imagePaddingSlider');
            const imagePaddingValue = document.getElementById('imagePaddingValue');
            
            imagePaddingSlider.addEventListener('input', () => {
                imagePaddingValue.textContent = imagePaddingSlider.value;
                imageModeSettings.padding = parseInt(imagePaddingSlider.value);
                updatePreview();
            });
            
            // Text input
            document.getElementById('textInput').addEventListener('input', updatePreview);
            
            // Font selection
            document.querySelectorAll('input[name="fontType"]').forEach(radio => {
                radio.addEventListener('change', updatePreview);
            });
            
            // Direction selection
            document.querySelectorAll('input[name="direction"]').forEach(radio => {
                radio.addEventListener('change', updatePreview);
            });
            
            // Color reversal checkboxes
            document.getElementById('reverseColor').addEventListener('change', updatePreview);
            document.getElementById('imageReverseColor').addEventListener('change', updatePreview);
            
            // Denoising checkbox
            if (document.getElementById('enableDenoising')) {
                document.getElementById('enableDenoising').addEventListener('change', updatePreview);
            }
            
            // Action buttons
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('downloadTextBtn').addEventListener('click', downloadText);
            document.getElementById('downloadImageBtn').addEventListener('click', downloadImage);
            
            // Generate buttons
            // Remove generate button listeners - now using real-time updates
            
            // Set device-specific default direction
            const currentSelection = document.querySelector('input[name="direction"]:checked');
            if (!currentSelection) {
                if (isMobileDevice()) {
                    document.querySelector('input[name="direction"][value="vertical"]').checked = true;
                } else {
                    document.querySelector('input[name="direction"][value="horizontal"]').checked = true;
                }
            }
            
            // Tab functionality
            initializeTabs();
            
            // Image upload functionality
            initializeImageUpload();
            
            // Initial preview update
            setTimeout(() => {
                updatePreview();
            }, 0);
        });
        
        // Tab switching functionality
        function initializeTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    
                    // Remove all active classes
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to current selected tab
                    button.classList.add('active');
                    if (tabId === 'text') {
                        document.getElementById('textTab').classList.add('active');
                        
                        // Save image mode settings (if currently in image mode)
                        if (currentInputMode === 'image') {
                            imageModeSettings.height = parseInt(document.getElementById('imageHeightSlider').value);
                            imageModeSettings.padding = parseInt(document.getElementById('imagePaddingSlider').value);
                        }
                        
                        currentInputMode = 'text'; // Update current mode
                        
                        // Text mode: adjust height slider range to 10-60
                        const heightSlider = document.getElementById('heightSlider');
                        const heightMaxLabel = heightSlider.nextElementSibling;
                        heightSlider.max = 60;
                        heightMaxLabel.textContent = '60';
                        
                        // Restore text mode settings
                        heightSlider.value = textModeSettings.height;
                        document.getElementById('heightValue').textContent = textModeSettings.height;
                        document.getElementById('paddingSlider').value = textModeSettings.padding;
                        document.getElementById('paddingValue').textContent = textModeSettings.padding;
                        
                        // If text input has content, regenerate preview
                        const textInput = document.getElementById('textInput').value.trim();
                        if (textInput) {
                            setTimeout(() => updatePreview(), 0);
                        } else {
                            // No text, clear preview
                            document.getElementById('moonArt').textContent = '<!-- Generated result will appear here -->';
                            document.getElementById('debugInfo').style.display = 'none';
                            document.getElementById('actionButtons').style.display = 'none';
                        }
                    } else if (tabId === 'image') {
                        document.getElementById('imageTab').classList.add('active');
                        
                        // Save text mode settings (if currently in text mode)
                        if (currentInputMode === 'text') {
                            textModeSettings.height = parseInt(document.getElementById('heightSlider').value);
                            textModeSettings.padding = parseInt(document.getElementById('paddingSlider').value);
                        }
                        
                        currentInputMode = 'image'; // Update current mode
                        
                        // If there's uploaded image, regenerate preview
                        if (lastUploadedImageSrc) {
                            setTimeout(() => updatePreview(), 0);
                        } else {
                            // No image, clear preview
                            document.getElementById('moonArt').textContent = '<!-- Generated result will appear here -->';
                            document.getElementById('debugInfo').style.display = 'none';
                            document.getElementById('actionButtons').style.display = 'none';
                        }
                    }
                });
            });
        }
        
        // Image upload functionality
        function initializeImageUpload() {
            const imageInput = document.getElementById('imageInput');
            const uploadArea = document.getElementById('uploadArea');
            
            // Click upload area
            uploadArea.addEventListener('click', () => {
                imageInput.click();
            });
            
            // File selection
            imageInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop upload
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type.startsWith('image/')) {
                    handleFile(files[0]);
                }
            });
            
            // Handle file selection
            function handleFileSelect(e) {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleFile(file);
                }
            }
            
            // Handle file
            function handleFile(file) {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    // Save image source and set current mode
                    lastUploadedImageSrc = e.target.result;
                    currentInputMode = 'image';
                    console.log('Image uploaded, switching to image mode');
                    
                    // Auto generate preview
                    setTimeout(() => {
                        generateFromImage(e.target.result);
                    }, 100);
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Generate moon art from image (full implementation)
        async function generateFromImage(imageSrc) {
            try {
                // Show processing status
                document.getElementById('moonArt').textContent = 'Processing...';
                
                // Get user settings
                const height = parseInt(document.getElementById('imageHeightSlider').value);
                const padding = parseInt(document.getElementById('imagePaddingSlider').value);
                const reverseColor = document.getElementById('imageReverseColor').checked;
                const enableDenoising = document.getElementById('enableDenoising')?.checked || true;
                const adhesionCoefficient = 2; // Fixed value
                
                // Create image processor
                const imageProcessor = new ImageProcessor();
                
                // Process image (fixed enable grayscale processing)
                const imageData = await imageProcessor.loadAndProcessImage(imageSrc, height, true);
                
                console.log(`Image data ready: ${imageData.width}x${imageData.height}`);
                
                // Use SimpleMoonGenerator's specialized image processing flow
                const generator = new SimpleMoonGenerator();
                
                // Use specialized image processing method (skip text optimization algorithms)
                let result = generator.generateFromImage(
                    imageData.matrix,
                    imageData.width,
                    imageData.height,
                    padding // Pass padding parameter directly
                );
                
                console.log(`Image moon art generation complete, lines: ${result.split('\n').length}`);
                
                // Apply color reversal (if needed)
                if (reverseColor) {
                    result = result.split('\n').map(line => {
                        return Array.from(line).map(char => {
                            // Use existing reverseMoon method
                            return generator.reverseMoon(char);
                        }).join('');
                    }).join('\n');
                    console.log(`Color reversal complete`);
                }
                
                // Display result
                document.getElementById('moonArt').textContent = result;
                document.getElementById('actionButtons').style.display = 'flex';
                
                // Image mode doesn't show debug info (no vertical processing etc. text optimization)
                document.getElementById('debugInfo').style.display = 'none';
                
                console.log(`Image conversion complete! Final result lines: ${result.split('\n').length}`);
                
            } catch (error) {
                console.error('Image processing failed:', error);
                document.getElementById('moonArt').textContent = 'Error: Failed to process image';
                document.getElementById('actionButtons').style.display = 'none';
            }
        }
    </script>
</body>
</html>