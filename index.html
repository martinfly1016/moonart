<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ | æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆä½œæˆ | ç„¡æ–™ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›ãƒ„ãƒ¼ãƒ« - MojiMoon</title>
<meta name="description" content="æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã‚’ç¾ã—ã„æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›ã™ã‚‹ç„¡æ–™ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã€‚ç¸¦æ›¸ããƒ»æ¨ªæ›¸ãå¯¾å¿œã€è¤‡æ•°ãƒ•ã‚©ãƒ³ãƒˆé¸æŠå¯èƒ½ã€‚æœˆã®æº€æ¬ ã‚’è¡¨ç¾ã—ãŸãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚¢ã‚¹ã‚­ãƒ¼ã‚¢ãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ">
<meta name="keywords" content="æœˆæ–‡å­—,çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆ,ãƒ†ã‚­ã‚¹ãƒˆã‚¢ãƒ¼ãƒˆ,ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼,ç„¡æ–™ãƒ„ãƒ¼ãƒ«,ã‚¹ãƒãƒ›,ã‚ªãƒ³ãƒ©ã‚¤ãƒ³">
<meta name="author" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
<meta name="robots" content="index,follow">
<meta property="og:title" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
<meta property="og:description" content="ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›ã™ã‚‹ç„¡æ–™ãƒ„ãƒ¼ãƒ«">
<meta property="og:type" content="website">
<meta property="og:url" content="https://mojimoon.com/">
<meta property="og:image" content="https://mojimoon.com/moon_icon.png">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@mojimoon">
<meta name="twitter:title" content="æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼">
<meta name="twitter:description" content="ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›">
<meta name="twitter:image" content="https://mojimoon.com/moon_icon.png">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ™</text></svg>">
<link rel="icon" type="image/png" sizes="32x32" href="/moon_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="/moon_icon.png">
<link rel="apple-touch-icon" href="/moon_icon.png">
<link rel="canonical" href="https://mojimoon.com/">
<link rel="alternate" href="https://mojimoon.com/" hreflang="ja">
<link rel="alternate" href="https://mojimoon.com/index_en.html" hreflang="en">
<script type="application/ld+json">
{
"@context": "https://schema.org",
"@type": "WebApplication",
"name": "æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼",
"description": "ãƒ†ã‚­ã‚¹ãƒˆã‚’æœˆã®çµµæ–‡å­—ã‚¢ãƒ¼ãƒˆã«å¤‰æ›",
"applicationCategory": "UtilityApplication",
"operatingSystem": "All",
"inLanguage": "ja",
"isAccessibleForFree": true
}
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WD9XP5ERGX"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WD9XP5ERGX');
</script>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
color: white;
padding: 20px;
}
.container {
max-width: 800px;
margin: 0 auto;
}
.header {
text-align: center;
margin-bottom: 30px;
position: relative;
}
.header h1 {
font-size: 1.8rem;
}
.header-content {
display: flex;
align-items: center;
justify-content: center;
gap: 20px;
}
.header-left {
flex-shrink: 0;
}
.ad-banner {
flex-shrink: 0;
border-radius: 8px;
overflow: hidden;
}
.ad-banner a {
display: block;
}
.ad-banner img {
display: block;
height: auto;
width: auto;
}
.mobile-footer-nav {
display: none;
}
.guide-link {
display: inline-block;
margin-top: 10px;
padding: 8px 16px;
background: rgba(255, 255, 255, 0.1);
color: white;
text-decoration: none;
border-radius: 20px;
font-size: 14px;
font-weight: 500;
border: 1px solid rgba(255, 255, 255, 0.2);
transition: all 0.2s ease;
backdrop-filter: blur(10px);
}
.guide-link:hover {
background: rgba(255, 255, 255, 0.2);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.lang-switcher {
display: inline-block;
margin-top: 10px;
padding: 8px 16px;
background: rgba(255, 255, 255, 0.1);
color: white;
text-decoration: none;
border-radius: 20px;
font-size: 14px;
font-weight: 500;
border: 1px solid rgba(255, 255, 255, 0.2);
transition: all 0.2s ease;
backdrop-filter: blur(10px);
}
.lang-switcher:hover {
background: rgba(255, 255, 255, 0.2);
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.control-panel {
background: rgba(255, 255, 255, 0.1);
border-radius: 15px;
padding: 25px;
margin-bottom: 20px;
backdrop-filter: blur(10px);
}
.form-group {
margin-bottom: 20px;
}
.form-group label {
display: block;
margin-bottom: 8px;
font-weight: 600;
}
.text-input {
width: 100%;
height: 48px;
padding: 12px;
border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 8px;
background: rgba(255, 255, 255, 0.1);
color: white;
font-size: 16px;
}
.text-input::placeholder {
color: rgba(255, 255, 255, 0.6);
}
.height-control {
display: flex;
align-items: center;
gap: 8px;
}
.height-slider {
flex: 1;
height: 6px;
background: rgba(255, 255, 255, 0.2);
border-radius: 3px;
outline: none;
-webkit-appearance: none;
}
.height-slider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 18px;
height: 18px;
background: #fbbf24;
border-radius: 50%;
cursor: pointer;
box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
transition: all 0.2s ease;
}
.height-slider::-webkit-slider-thumb:hover {
background: #f59e0b;
transform: scale(1.1);
box-shadow: 0 4px 12px rgba(251, 191, 36, 0.6);
}
.font-select {
width: 100%;
padding: 12px;
border: 1px solid rgba(255, 255, 255, 0.3);
border-radius: 8px;
background: rgba(255, 255, 255, 0.1);
color: white;
font-size: 16px;
outline: none;
}
.font-select option {
background: #4c1d95;
color: white;
}
.generate-btn {
width: 100%;
padding: 15px;
background: linear-gradient(135deg, #8b5cf6, #ec4899);
border: none;
border-radius: 10px;
color: white;
font-size: 16px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s;
}
.generate-btn:hover {
transform: translateY(-2px);
}
.preview-panel {
background: rgba(0, 0, 0, 0.3);
border-radius: 15px;
padding: 20px;
min-height: 300px;
width: 100%;
max-width: 100%;
overflow-x: auto;
}
.moon-art {
font-family: monospace;
font-size: 12px;
line-height: 1.4;
letter-spacing: 0.1em;
white-space: pre;
width: fit-content;
color: #fff;
padding-top: 5px;
}
.action-buttons {
display: flex;
gap: 10px;
margin-top: 15px;
flex-wrap: wrap;
}
.action-btn {
display: flex;
align-items: center;
gap: 8px;
padding: 10px 15px;
border: none;
border-radius: 8px;
font-size: 14px;
font-weight: 500;
cursor: pointer;
transition: all 0.2s ease;
color: white;
flex: 1;
min-width: 140px;
}
.copy-btn {
background: linear-gradient(135deg, #10b981, #059669);
}
.copy-btn:hover {
background: linear-gradient(135deg, #059669, #047857);
transform: translateY(-1px);
}
.download-btn {
background: linear-gradient(135deg, #3b82f6, #1d4ed8);
}
.download-btn:hover {
background: linear-gradient(135deg, #1d4ed8, #1e40af);
transform: translateY(-1px);
}
.btn-icon {
font-size: 16px;
}
.btn-text {
font-size: 13px;
}
.copy-btn.success {
background: linear-gradient(135deg, #059669, #047857);
}
.direction-control {
display: flex;
gap: 12px;
margin-top: 8px;
}
.radio-option {
display: flex;
align-items: center;
gap: 8px;
cursor: pointer;
font-size: 14px;
}
.radio-option input[type="radio"],
.radio-option input[type="checkbox"] {
width: 18px;
height: 18px;
accent-color: #8b5cf6;
}
.radio-label {
font-weight: 500;
font-size: 0.9rem;
}
.dual-control-row {
display: flex;
width: 100%;
max-width: 100%;
margin-bottom: 15px;
box-sizing: border-box;
gap: 0;
}
.dual-control-item {
flex: 0 0 50%;
box-sizing: border-box;
}
.dual-control-item:first-child {
flex: 0 0 50%;
}
.dual-control-item:last-child {
flex: 0 0 50%;
}
.dual-control-item > label,
.dual-control-item > .height-control,
.dual-control-item > .font-select {
width: 90%;
margin-left: 0;
}
.footer {
margin-top: 40px;
padding: 20px 15px;
}
.footer-bookmark-btn {
background: none;
border: none;
color: #fbbf24;
font-size: 1rem;
font-weight: 600;
cursor: pointer;
text-decoration: underline;
padding: 0;
margin: 0 2px;
transition: color 0.2s ease;
}
.footer-bookmark-btn:hover {
color: #f59e0b;
}
.floating-bookmark {
position: fixed;
top: 20px;
right: 20px;
background: linear-gradient(135deg, #fbbf24, #f59e0b);
border: none;
border-radius: 25px;
color: white;
font-size: 14px;
font-weight: 500;
cursor: pointer;
z-index: 1000;
box-shadow: 0 4px 15px rgba(251, 191, 36, 0.3);
transition: all 0.3s ease;
display: flex;
align-items: center;
justify-content: center;
padding: 12px 16px;
gap: 6px;
}
.floating-bookmark:hover {
transform: scale(1.05);
box-shadow: 0 6px 20px rgba(251, 191, 36, 0.5);
}
@media (max-width: 768px) {
.header-content {
flex-direction: column;
gap: 8px;
align-items: flex-start;
}
.header-left {
text-align: left;
}
.header-left .guide-link,
.header-left .lang-switcher {
display: none;
}
.ad-banner {
width: 100%;
display: flex;
justify-content: center;
box-shadow: none;
}
.ad-banner img {
height: auto;
width: 100%;
max-width: 280px;
}
.header {
margin-bottom: 10px;
}
.header h1 {
font-size: 0.95rem;
margin-bottom: 0;
white-space: nowrap;
}
.mobile-footer-nav {
display: flex;
justify-content: center;
gap: 10px;
margin-top: 20px;
padding: 15px 0;
}
.guide-link {
font-size: 13px;
padding: 6px 12px;
}
.lang-switcher {
font-size: 13px;
padding: 6px 12px;
}
.control-panel {
padding: 12px;
margin-bottom: 15px;
}
.form-group {
margin-bottom: 15px;
}
.form-group h3 {
font-size: 0.9rem;
margin-bottom: 6px;
}
.floating-bookmark {
display: none;
}
body {
padding-top: 10px;
}
.footer h2 {
font-size: 1.1rem;
}
.action-buttons {
gap: 5px;
flex-wrap: nowrap;
}
.action-btn {
min-width: 0;
padding: 8px 6px;
font-size: 12px;
flex: 1;
}
.btn-icon {
font-size: 14px;
}
.btn-text {
font-size: 11px;
}
.direction-control {
gap: 8px;
}
.preview-panel {
width: 100%;
max-width: 100%;
min-width: unset;
overflow-x: auto;
}
.moon-art {
font-size: 10px;
}
.dual-control-row {
gap: 0;
width: 100%;
max-width: 100%;
}
.dual-control-item {
flex: 0 0 50%;
}
.dual-control-item label {
white-space: nowrap;
overflow: visible;
text-overflow: clip;
}
.height-control {
gap: 6px;
}
.height-control span {
font-size: 12px;
min-width: 10px;
}
.dual-control-item:first-child {
flex: 0 0 50%;
}
.dual-control-item:last-child {
flex: 0 0 50%;
}
.dual-control-item > label,
.dual-control-item > .height-control,
.dual-control-item > .font-select {
width: 95%;
}
}
.input-tabs {
display: flex;
margin-bottom: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}
.tab-button {
flex: 1;
background: none;
border: none;
color: rgba(255, 255, 255, 0.7);
font-size: 1rem;
font-weight: 600;
padding: 12px 20px;
cursor: pointer;
transition: all 0.3s ease;
border-bottom: 3px solid transparent;
}
.tab-button.active {
color: white;
border-bottom-color: #fbbf24;
background: rgba(255, 255, 255, 0.05);
}
.tab-button:hover {
color: white;
background: rgba(255, 255, 255, 0.1);
}
.tab-content {
display: none;
}
.tab-content.active {
display: block;
}
.image-upload-area {
border: 2px dashed rgba(255, 255, 255, 0.3);
border-radius: 12px;
padding: 40px 20px;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
background: rgba(255, 255, 255, 0.05);
min-height: 200px;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
}
.image-upload-area:hover {
border-color: #fbbf24;
background: rgba(251, 191, 36, 0.1);
}
.image-upload-area.dragover {
border-color: #fbbf24;
background: rgba(251, 191, 36, 0.15);
}
.upload-icon {
font-size: 3rem;
margin-bottom: 16px;
color: rgba(255, 255, 255, 0.6);
}
.upload-text {
font-size: 1.1rem;
font-weight: 600;
margin-bottom: 8px;
color: white;
}
.upload-hint {
font-size: 0.9rem;
color: rgba(255, 255, 255, 0.7);
margin-bottom: 16px;
}
.upload-button {
background: linear-gradient(135deg, #fbbf24, #f59e0b);
color: white;
border: none;
padding: 10px 20px;
border-radius: 8px;
font-size: 0.9rem;
font-weight: 600;
cursor: pointer;
transition: all 0.2s;
}
.upload-button:hover {
transform: translateY(-1px);
box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
}
.image-preview {
display: none;
margin-top: 16px;
text-align: center;
}
.image-preview img {
max-width: 100%;
max-height: 200px;
border-radius: 8px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
.image-info {
margin-top: 12px;
font-size: 0.9rem;
color: rgba(255, 255, 255, 0.8);
}
.remove-image {
background: rgba(255, 255, 255, 0.2);
color: white;
border: none;
padding: 6px 12px;
border-radius: 6px;
font-size: 0.8rem;
cursor: pointer;
margin-top: 8px;
transition: all 0.2s;
}
.remove-image:hover {
background: rgba(255, 255, 255, 0.3);
}
.debug-header:hover {
background: rgba(255, 255, 255, 0.05);
border-radius: 6px;
padding: 8px;
margin: -8px;
}
.debug-controls {
max-height: 0;
opacity: 0;
transition: all 0.3s ease;
}
.debug-controls.expanded {
max-height: 500px;
opacity: 1;
display: block !important;
}
.label-style{font-weight:600;margin-bottom:8px;display:block}
.hidden{display:none}
.flex-center{display:flex;align-items:center;gap:8px}
.btn-footer{display:inline-block;padding:12px 24px;color:white;text-decoration:none;border-radius:8px;font-size:1rem;transition:transform 0.2s,box-shadow 0.2s;margin:5px}
.btn-cyan{background:linear-gradient(135deg,#06B6D4,#0891B2)}
.btn-green{background:linear-gradient(135deg,#10b981,#059669)}
.btn-blue{background:linear-gradient(135deg,#3b82f6,#1d4ed8)}
.friend-link{color:#6b7280;text-decoration:none;margin:0 8px}
</style>
</head>
<body>
<button id="bookmarkBtn" class="floating-bookmark" title="ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ">
â­ ãŠæ°—ã«å…¥ã‚Š
</button>
<div class="container">
<header class="header">
<div class="header-content">
<div class="header-left">
<h1>ğŸŒ™ æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
<a href="guide.html" class="guide-link">ğŸ“– ä½¿ç”¨ã‚¬ã‚¤ãƒ‰</a>
<a href="index_en.html" class="lang-switcher">ğŸŒ English</a>
</div>
<div class="ad-banner">
<a href="https://www.genhub.jp?refer=mojimoon" target="_blank" rel="noopener noreferrer sponsored">
<img src="banner.jpg" alt="åºƒå‘Š">
</a>
</div>
</div>
</header>
<div class="control-panel">
<div class="input-tabs">
<button class="tab-button active" data-tab="text">ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</button>
<button class="tab-button" data-tab="image">ç”»åƒå…¥åŠ›</button>
</div>
<div class="tab-content active" id="textTab">
<div class="form-group">
<input type="text" id="textInput" class="text-input" placeholder="å¤‰æ›ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" value="æœˆæ–‡å­—">
</div>
<div class="form-group">
<div class="direction-control">
<label class="radio-option">
<input type="radio" name="textDirection" value="vertical">
<span class="radio-label">ç¸¦æ›¸ã</span>
</label>
<label class="radio-option">
<input type="radio" name="textDirection" value="horizontal">
<span class="radio-label">æ¨ªæ›¸ã</span>
</label>
</div>
</div>
<div class="form-group">
<div class="dual-control-row">
<div class="dual-control-item">
<label class="label-style">ãƒ•ã‚©ãƒ³ãƒˆé¸æŠ</label>
<select id="fontSelect" class="font-select">
<option value="default" selected>ã‚·ã‚¹ãƒ†ãƒ æ—¢å®š</option>
<option value="gothic">ã‚´ã‚·ãƒƒã‚¯ä½“</option>
<option value="mincho">æ˜æœä½“</option>
</select>
</div>
<div class="dual-control-item">
<label class="label-style">æ–‡å­—é–“éš”: <span id="spacingValue">2</span></label>
<div class="height-control">
<span>0</span>
<input type="range" id="spacingSlider" class="height-slider" min="0" max="10" value="2">
<span>10</span>
</div>
</div>
</div>
</div>
</div>
<div class="tab-content" id="imageTab">
<div class="form-group">
<div class="image-upload-area" id="imageUploadArea">
<div class="upload-icon">ğŸ“</div>
<div class="upload-text">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</div>
<div class="upload-hint">JPG, PNG, GIF ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</div>
<button class="upload-button" id="uploadButton">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
<input type="file" id="imageInput" accept="image/*" style="display: none;">
</div>
<div class="image-preview" id="imagePreview">
<img id="previewImg" src="" alt="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼">
<div class="image-info" id="imageInfo"></div>
<button class="remove-image" id="removeImage">ç”»åƒã‚’å‰Šé™¤</button>
</div>
</div>
</div>
<div class="form-group">
<div class="dual-control-row">
<div class="dual-control-item">
<label class="label-style">
<span id="sliderLabel">é«˜ã•</span>: 
<span id="heightValue">10</span>
<span id="sliderUnit">è¡Œ</span>
</label>
<div class="height-control">
<span>10</span>
<input type="range" id="heightSlider" class="height-slider" min="10" max="60" value="10">
<span>60</span>
</div>
</div>
<div class="dual-control-item">
<label class="label-style">
ä½™ç™½: <span id="paddingValue">0</span>
</label>
<div class="height-control">
<span>0</span>
<input type="range" id="paddingSlider" class="height-slider" min="0" max="5" value="0">
<span>5</span>
</div>
</div>
</div>
<div style="display: flex; align-items: center; gap: 8px; font-weight: 600;">
<input type="checkbox" id="reverseColor" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
<label for="reverseColor" style="cursor: pointer; font-weight: 600;">åè‰²</label>
</div>
</div>
<div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); display: none !important;">
<div class="debug-header" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; margin-bottom: 15px;" onclick="toggleDebugSection()">
<h3 style="margin: 0; font-size: 1rem; font-weight: 600; color: #fbbf24;">è°ƒè¯•å‚æ•°</h3>
<span id="debugToggleIcon" style="color: #fbbf24; font-size: 1rem; transition: transform 0.3s ease;">â–¶</span>
</div>
<div id="debugControls" class="debug-controls" style="display: none; overflow: hidden; transition: all 0.3s ease;">
<div class="form-group">
<label>æ¨ªå‘ç²˜åˆç³»æ•°: <span id="adhesionValue">2</span></label>
<div class="height-control">
<span>0</span>
<input type="range" id="adhesionSlider" class="height-slider" min="0" max="6" value="2">
<span>6</span>
</div>
</div>
<div style="margin-top: 15px;">
<h4 style="margin-bottom: 10px; font-size: 0.9rem; font-weight: 600;">å‚ç›´åŒ–å¤„ç†</h4>
<div style="display: flex; gap: 20px;">
<label class="radio-option">
<input type="checkbox" id="verticalMedium" checked>
<span class="radio-label">ä¸­ç­‰å¯†åº¦</span>
</label>
<label class="radio-option">
<input type="checkbox" id="verticalHigh" checked>
<span class="radio-label">æ¬¡é«˜å¯†åº¦</span>
</label>
</div>
</div>
<div style="margin-top: 15px;">
<h4 style="margin-bottom: 10px; font-size: 0.9rem; font-weight: 600;">æ¨ªå‘åŠ å¼ºç®—æ³•</h4>
<div style="display: flex; gap: 20px;">
<label class="radio-option">
<input type="checkbox" id="enableDenoising" checked>
<span class="radio-label">å»å™ªå¤„ç†</span>
</label>
</div>
</div>
<div style="margin-top: 15px;">
</div>
</div>
</div>
<div id="actionButtons" class="action-buttons" style="display: none;">
<button id="copyBtn" class="action-btn copy-btn">
<span class="btn-icon">ğŸ“‹</span>
<span class="btn-text">ã‚³ãƒ”ãƒ¼</span>
</button>
<button id="downloadTextBtn" class="action-btn download-btn">
<span class="btn-icon">ğŸ“„</span>
<span class="btn-text">ãƒ†ã‚­ã‚¹ãƒˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
</button>
<button id="downloadImageBtn" class="action-btn download-btn">
<span class="btn-icon">ğŸ–¼ï¸</span>
<span class="btn-text">ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
</button>
</div>
</div>
</div>
<div class="container">
<div class="preview-panel">
<h2 style="margin-bottom: 8px; font-size: 12px; font-weight: 600;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
<div id="debugInfo" style="margin-bottom: 10px; font-size: 11px; color: #fbbf24; font-family: monospace; display: none !important;">
<div>å‚ç›´åŒ–å‡¦ç†: <span id="verticalProcessingStatus">æœ‰åŠ¹</span></div>
<div>å¯¾è±¡å¯†åº¦ãƒ¬ãƒ™ãƒ«: <span id="targetDensityLevels">ä¸­ç­‰å¯†åº¦</span></div>
<div>é–¾å€¤n: <span id="thresholdN">2</span></div>
<div>å‡¦ç†ãƒ¢ãƒ¼ãƒ‰: <span id="processingMode">ä¸­ç­‰å¯†åº¦ï¼ˆãƒãƒ©ãƒ³ã‚¹é‡å¿ƒã®ã¿ï¼‰</span></div>
</div>
<div id="moonArt" class="moon-art"></div>
<div style="margin-top: 20px; display: none;">
<label>
<input type="checkbox" id="showDebugCanvas"> æ˜¾ç¤ºåŸå§‹Canvasè°ƒè¯•
</label>
</div>
<canvas id="debugCanvas" style="border: 1px solid #666; margin-top: 10px; background: white; display: none; max-width: 100%;"></canvas>
</div>
</div>
<script>
let currentInputMode = 'text'; 
let lastUploadedImageSrc = null; 
let textModeSettings = {
height: 10,
padding: 0
};
let imageModeSettings = {
height: 60,
padding: 0
};
const COLOR_LEVELS = {
BLACK: 0,
WHITE: 1
};
class ImageProcessor {
constructor() {
this.threshold = 128; 
this.bayerMatrix5x5 = [
[ 0, 12,  3, 15,  8],
[18,  6, 21,  9, 24],
[ 4, 16,  1, 13,  5],
[22, 10, 19,  7, 23],
[ 2, 14, 11, 20, 17]
];
}
async loadAndProcessImage(imageSrc, targetHeight, useGrayScale = false) {
return new Promise((resolve, reject) => {
const img = new Image();
img.onload = () => {
try {
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const aspectRatio = img.width / img.height;
const targetPixelHeight = targetHeight * 5; 
const targetPixelWidth = Math.round(targetPixelHeight * aspectRatio);
const finalHeight = Math.ceil(targetPixelHeight / 5) * 5;
const finalWidth = Math.ceil(targetPixelWidth / 5) * 5;
canvas.width = finalWidth;
canvas.height = finalHeight;
ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
const imageData = ctx.getImageData(0, 0, finalWidth, finalHeight);
const processedMatrix = useGrayScale 
? this.applyOrderedDithering(imageData)
: this.binarizeImage(imageData);
resolve({
matrix: processedMatrix,
width: finalWidth,
height: finalHeight
});
} catch (error) {
reject(error);
}
};
img.onerror = () => {
reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
};
img.src = imageSrc;
});
}
binarizeImage(imageData) {
const data = imageData.data;
const width = imageData.width;
const height = imageData.height;
const binaryMatrix = [];
for (let y = 0; y < height; y++) {
const row = [];
for (let x = 0; x < width; x++) {
const idx = (y * width + x) * 4;
const r = data[idx];
const g = data[idx + 1];
const b = data[idx + 2];
const gray = 0.299 * r + 0.587 * g + 0.114 * b;
row.push(gray < this.threshold ? 0 : 1);
}
binaryMatrix.push(row);
}
return binaryMatrix;
}
applyOrderedDithering(imageData) {
const data = imageData.data;
const width = imageData.width;
const height = imageData.height;
const result = [];
for (let y = 0; y < height; y++) {
const row = [];
for (let x = 0; x < width; x++) {
const idx = (y * width + x) * 4;
const r = data[idx];
const g = data[idx + 1];
const b = data[idx + 2];
const gray = 0.299 * r + 0.587 * g + 0.114 * b;
const matrixSize = 5;
const mx = x % matrixSize;
const my = y % matrixSize;
const threshold = (this.bayerMatrix5x5[my][mx] + 1) * 255 / 26;
row.push(gray > threshold ? 1 : 0);
}
result.push(row);
}
return result;
}
setThreshold(value) {
this.threshold = value;
}
}
class HorizontalEnhancer {
constructor() {
this.adhesionCoefficient = 2; 
this.enableDenoising = true; 
this.gapDistanceMap = this.initGapDistanceMap();
this.selfGapMap = {
'ğŸŒ”': 1,
'ğŸŒ“': 2, 
'ğŸŒ’': 3,
'ğŸŒ‘': 4,
'ğŸŒ˜': 3,
'ğŸŒ—': 2,
'ğŸŒ–': 1,
'ğŸŒ•': 0
};
}
setAdhesionCoefficient(coefficient) {
this.adhesionCoefficient = coefficient;
}
setEnableDenoising(enable) {
this.enableDenoising = enable;
}
initGapDistanceMap() {
const map = {};
const moons = ['ğŸŒ‘', 'ğŸŒ˜', 'ğŸŒ—', 'ğŸŒ–', 'ğŸŒ•', 'ğŸŒ”', 'ğŸŒ“', 'ğŸŒ’'];
map['ğŸŒ‘'] = {};
for (const moon of moons) {
map['ğŸŒ‘'][moon] = -1;
}
const distances = {
'ğŸŒ˜': { 'ğŸŒ˜': 3, 'ğŸŒ—': 3, 'ğŸŒ–': 3, 'ğŸŒ•': 3, 'ğŸŒ”': 4, 'ğŸŒ“': 5, 'ğŸŒ’': 6, 'ğŸŒ‘': -1 },
'ğŸŒ—': { 'ğŸŒ˜': 2, 'ğŸŒ—': 2, 'ğŸŒ–': 2, 'ğŸŒ•': 2, 'ğŸŒ”': 3, 'ğŸŒ“': 4, 'ğŸŒ’': 5, 'ğŸŒ‘': -1 },
'ğŸŒ–': { 'ğŸŒ˜': 1, 'ğŸŒ—': 1, 'ğŸŒ–': 1, 'ğŸŒ•': 1, 'ğŸŒ”': 2, 'ğŸŒ“': 3, 'ğŸŒ’': 4, 'ğŸŒ‘': -1 },
'ğŸŒ•': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ”': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ“': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 },
'ğŸŒ’': { 'ğŸŒ˜': 0, 'ğŸŒ—': 0, 'ğŸŒ–': 0, 'ğŸŒ•': 0, 'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': -1 }
};
return { ...map, ...distances };
}
getGapDistance(left, right) {
return this.gapDistanceMap[left]?.[right] || 0;
}
performAdhesion(left, right) {
const gap = this.getGapDistance(left, right);
if (gap <= 0 || gap > this.adhesionCoefficient) {
return [left, right];
}
const fillOptions = [
['ğŸŒ•', right], 
[left, 'ğŸŒ•'],  
['ğŸŒ•', 'ğŸŒ•']   
];
for (const [newLeft, newRight] of fillOptions) {
if (this.getGapDistance(newLeft, newRight) === 0) {
if (newLeft !== left && newRight === right) {
return [newLeft, newRight];
}
if (newLeft === left && newRight !== right) {
return [newLeft, newRight];
}
}
}
return ['ğŸŒ•', 'ğŸŒ•'];
}
selfAdhesion(lines) {
const processedLines = [];
for (let line of lines) {
if (line.length === 0) {
processedLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length; i++) {
const current = chars[i];
if (current === 'ğŸŒ•' || current === 'ğŸŒ‘') {
continue;
}
let leftIsEmpty = false, rightIsEmpty = false;
if (i === 0) {
leftIsEmpty = true; 
} else {
leftIsEmpty = (chars[i - 1] === 'ğŸŒ‘');
}
if (i === chars.length - 1) {
rightIsEmpty = true; 
} else {
rightIsEmpty = (chars[i + 1] === 'ğŸŒ‘');
}
if (leftIsEmpty && rightIsEmpty) {
const selfGap = this.selfGapMap[current] || 0;
if (selfGap <= this.adhesionCoefficient) {
newChars[i] = 'ğŸŒ•';
}
}
}
processedLines.push(newChars.join(''));
}
return processedLines;
}
enhance(moonArtText) {
if (this.adhesionCoefficient === 0) {
return moonArtText;
}
const lines = moonArtText.split('\n');
const processedLines = [];
for (let line of lines) {
if (line.length === 0) {
processedLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length - 1; i++) {
const [newLeft, newRight] = this.performAdhesion(newChars[i], newChars[i + 1]);
newChars[i] = newLeft;
newChars[i + 1] = newRight;
}
processedLines.push(newChars.join(''));
}
const selfAdhesedLines = this.selfAdhesion(processedLines);
if (this.enableDenoising) {
return this.denoise(selfAdhesedLines);
} else {
return selfAdhesedLines.join('\n');
}
}
denoise(lines) {
const denoiseLines = [];
for (let line of lines) {
if (line.length === 0) {
denoiseLines.push(line);
continue;
}
const chars = Array.from(line);
const newChars = [...chars];
for (let i = 0; i < chars.length; i++) {
const current = chars[i];
if (current === 'ğŸŒ‘') continue;
let leftGap = -1, rightGap = -1;
if (i > 0) {
leftGap = this.getGapDistance(chars[i - 1], current);
}
if (i < chars.length - 1) {
rightGap = this.getGapDistance(current, chars[i + 1]);
}
if (current !== 'ğŸŒ•' && 
(leftGap > 0 || leftGap === -1) && 
(rightGap > 0 || rightGap === -1)) {
newChars[i] = 'ğŸŒ‘';
}
}
denoiseLines.push(newChars.join(''));
}
return denoiseLines.join('\n');
}
}
class SimpleMoonGenerator {
constructor() {
this.moonPhases = [
{ emoji: 'ğŸŒ‘', minBlack: 0, maxBlack: 0 },    
{ emoji: 'ğŸŒ˜', minBlack: 1, maxBlack: 4 },    
{ emoji: 'ğŸŒ—', minBlack: 5, maxBlack: 8 },    
{ emoji: 'ğŸŒ–', minBlack: 9, maxBlack: 12 },   
{ emoji: 'ğŸŒ•', minBlack: 13, maxBlack: 16 }   
];
this.verticalProcessingPositions = [];
}
grayToColorLevel(gray) {
return gray < 128 ? 0 : 1; 
}
gridToMoonWithMeta(grid) {
let blackCount = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) { 
blackCount++;
}
}
}
const densityLevel = this.getDensityLevel(blackCount);
const centerX = this.calculateHorizontalCenter(grid);
const bias = this.getBias(centerX);
let originalMoonPhase;
switch (densityLevel.name) {
case 'æä½å¯†åº¦':
originalMoonPhase = 'ğŸŒ‘';
break;
case 'é«˜å¯†åº¦':
originalMoonPhase = 'ğŸŒ•';
break;
case 'ä¸­ä½å¯†åº¦':
case 'ä¸­ç­‰å¯†åº¦':
case 'æ¬¡é«˜å¯†åº¦':
originalMoonPhase = this.selectMoonPhase(densityLevel.name, bias);
break;
default:
originalMoonPhase = 'ğŸŒ‘';
}
return {
originalMoonPhase: originalMoonPhase,
finalMoonPhase: originalMoonPhase, 
densityLevel: densityLevel.name,
densitySymbol: densityLevel.debugSymbol,
bias: bias,
blackCount: blackCount,
centerX: centerX
};
}
gridToMoon(grid) {
return this.gridToMoonWithMeta(grid).finalMoonPhase;
}
getDensityLevel(blackCount) {
const densityLevels = [
{ name: 'æä½å¯†åº¦', minPixels: 1, maxPixels: 4, debugSymbol: 'â¬›' },
{ name: 'ä¸­ä½å¯†åº¦', minPixels: 5, maxPixels: 8, debugSymbol: 'ğŸŸ¦' },
{ name: 'ä¸­ç­‰å¯†åº¦', minPixels: 9, maxPixels: 14, debugSymbol: 'ğŸŸ§' },
{ name: 'æ¬¡é«˜å¯†åº¦', minPixels: 15, maxPixels: 21, debugSymbol: 'ğŸŸ¨' },
{ name: 'é«˜å¯†åº¦', minPixels: 22, maxPixels: 25, debugSymbol: 'æ— ' }
];
if (blackCount === 0) {
return { name: 'ç©ºç™½', debugSymbol: 'â¬œ' };
}
for (const level of densityLevels) {
if (blackCount >= level.minPixels && blackCount <= level.maxPixels) {
return level;
}
}
return densityLevels[4];
}
calculateHorizontalCenter(grid) {
let weightedX = 0;
let totalBlack = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) { 
weightedX += x;
totalBlack++;
}
}
}
return totalBlack > 0 ? weightedX / totalBlack : 2; 
}
getBias(centerX) {
if (centerX < 1.8) {
return 'left';
} else if (centerX > 2.2) {
return 'right';
} else {
return 'balanced';
}
}
selectMoonPhase(densityLevel, bias) {
const phaseMap = {
'ä¸­ä½å¯†åº¦': { left: 'ğŸŒ˜', right: 'ğŸŒ’', balanced: 'ğŸŒ•' },
'ä¸­ç­‰å¯†åº¦': { left: 'ğŸŒ—', right: 'ğŸŒ“', balanced: 'ğŸŒ•' },
'æ¬¡é«˜å¯†åº¦': { left: 'ğŸŒ–', right: 'ğŸŒ”', balanced: 'ğŸŒ•' }
};
return phaseMap[densityLevel]?.[bias] || 'ğŸŒ•';
}
reverseMoon(emoji) {
const reverseMap = {
'ğŸŒ‘': 'ğŸŒ•', 
'ğŸŒ’': 'ğŸŒ–', 
'ğŸŒ“': 'ğŸŒ—', 
'ğŸŒ”': 'ğŸŒ˜', 
'ğŸŒ•': 'ğŸŒ‘', 
'ğŸŒ–': 'ğŸŒ’', 
'ğŸŒ—': 'ğŸŒ“', 
'ğŸŒ˜': 'ğŸŒ”'  
};
return reverseMap[emoji] || emoji;
}
getCharacterVacancy(moonPhase) {
let normalizedPhase = moonPhase.normalize('NFC').replace(/[\uFE0E\uFE0F]/g, '').trim();
const vacancyMapByCodePoint = {
0x1F314: 1, 
0x1F313: 2, 
0x1F312: 3, 
0x1F311: 4, 
0x1F318: 3, 
0x1F317: 2, 
0x1F316: 1, 
0x1F315: 0  
};
const codePoint = normalizedPhase.codePointAt(0);
if (codePoint && vacancyMapByCodePoint.hasOwnProperty(codePoint)) {
return vacancyMapByCodePoint[codePoint];
}
const vacancyMap = {
'ğŸŒ”': 1, 'ğŸŒ“': 2, 'ğŸŒ’': 3, 'ğŸŒ‘': 4,
'ğŸŒ˜': 3, 'ğŸŒ—': 2, 'ğŸŒ–': 1, 'ğŸŒ•': 0
};
return vacancyMap[normalizedPhase] || 4; 
}
shouldApplyVerticalProcessing(cellMeta, targetDensityLevels) {
return targetDensityLevels.includes(cellMeta.densityLevel) && 
cellMeta.bias === 'balanced';
}
applyVerticalProcessing(gridWithMeta, targetDensityLevels, thresholdN = 2) {
const gridHeight = gridWithMeta.length;
const gridWidth = gridWithMeta[0]?.length || 0;
this.verticalProcessingPositions = [];
for (let row = 1; row < gridHeight; row++) {
for (let col = 0; col < gridWidth; col++) {
const currentCell = gridWithMeta[row][col];
if (this.shouldApplyVerticalProcessing(currentCell, targetDensityLevels)) {
this.verticalProcessingPositions.push({
row: row,
col: col,
densityLevel: currentCell.densityLevel
});
const aboveCell = gridWithMeta[row - 1][col];
const aboveVacancy = this.getCharacterVacancy(aboveCell.finalMoonPhase);
if (aboveVacancy <= thresholdN) {
currentCell.finalMoonPhase = 'ğŸŒ‘';
} else {
currentCell.finalMoonPhase = 'ğŸŒ•';
}
}
}
}
return gridWithMeta;
}
getDensityDebugSymbol(densityLevel) {
const DENSITY_DEBUG_SYMBOLS = {
'ä¸­ç­‰å¯†åº¦': 'ğŸŸ§',  
'ä¸­ä½å¯†åº¦': 'ğŸŸ¦',  
'æ¬¡é«˜å¯†åº¦': 'ğŸŸ¨',  
'æä½å¯†åº¦': 'â¬›',  
'é«˜å¯†åº¦': 'ğŸŒ•'     
};
return DENSITY_DEBUG_SYMBOLS[densityLevel] || 'â“';
}
applySpacing(text, spacing) {
if (spacing <= 0) return text;
const lines = text.split('\n');
const spacedLines = [];
for (const line of lines) {
if (line.length === 0) {
spacedLines.push(line);
continue;
}
const chars = Array.from(line);
const spacedChars = [];
for (let i = 0; i < chars.length; i++) {
spacedChars.push(chars[i]);
if (i < chars.length - 1) {
spacedChars.push('ğŸŒ‘'.repeat(spacing));
}
}
spacedLines.push(spacedChars.join(''));
}
return spacedLines.join('\n');
}
applyPadding(text, padding) {
if (padding <= 0) return text;
const lines = text.split('\n');
if (lines.length === 0) return text;
const maxWidth = Math.max(...lines.map(line => Array.from(line).length));
const paddingChar = 'ğŸŒ‘';
const horizontalPadding = paddingChar.repeat(padding);
const fullPaddingLine = paddingChar.repeat(maxWidth + 2 * padding);
const paddedLines = [];
for (let i = 0; i < padding; i++) {
paddedLines.push(fullPaddingLine);
}
for (const line of lines) {
const chars = Array.from(line);
while (chars.length < maxWidth) {
chars.push('ğŸŒ‘');
}
const paddedLine = horizontalPadding + chars.join('') + horizontalPadding;
paddedLines.push(paddedLine);
}
for (let i = 0; i < padding; i++) {
paddedLines.push(fullPaddingLine);
}
return paddedLines.join('\n');
}
generateFromPixelMatrix(pixelMatrix, width, height, enableVerticalProcessing = true, padding = 0) {
this.verticalProcessingPositions = [];
const metaGrid = [];
const gridSize = 5;
for (let y = 0; y < height; y += gridSize) {
const metaRow = [];
for (let x = 0; x < width; x += gridSize) {
const subGrid = [];
for (let dy = 0; dy < gridSize; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < gridSize; dx++) {
const py = y + dy;
const px = x + dx;
if (py < height && px < width) {
subGrid[dy][dx] = pixelMatrix[py][px];
} else {
subGrid[dy][dx] = 1; 
}
}
}
const cellMeta = this.gridToMoonWithMeta(subGrid);
metaRow.push(cellMeta);
}
if (metaRow.length > 0) {
metaGrid.push(metaRow);
}
}
if (enableVerticalProcessing) {
const targetDensityLevels = [];
if (document.getElementById('verticalMedium').checked) {
targetDensityLevels.push('ä¸­ç­‰å¯†åº¦');
}
if (document.getElementById('verticalHigh').checked) {
targetDensityLevels.push('æ¬¡é«˜å¯†åº¦');
}
const thresholdN = 2; 
this.applyVerticalProcessing(metaGrid, targetDensityLevels, thresholdN);
}
const resultLines = metaGrid.map(row => 
row.map(cell => cell.finalMoonPhase).join('')
);
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
generateFromImage(pixelMatrix, width, height, padding = 0) {
const metaGrid = [];
const gridSize = 5;
for (let y = 0; y < height; y += gridSize) {
const metaRow = [];
for (let x = 0; x < width; x += gridSize) {
const subGrid = [];
for (let dy = 0; dy < gridSize; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < gridSize; dx++) {
const py = y + dy;
const px = x + dx;
if (py < height && px < width) {
subGrid[dy][dx] = pixelMatrix[py][px];
} else {
subGrid[dy][dx] = 1; 
}
}
}
const moonPhase = this.gridToMoonForImage(subGrid);
metaRow.push(moonPhase);
}
if (metaRow.length > 0) {
metaGrid.push(metaRow);
}
}
const resultLines = metaGrid.map(row => row.join(''));
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
gridToMoonForImage(grid) {
let blackCount = 0;
for (let y = 0; y < 5; y++) {
for (let x = 0; x < 5; x++) {
if (grid[y][x] === 0) {
blackCount++;
}
}
}
const ratio = blackCount / 25;
if (ratio === 0) return 'ğŸŒ‘';        
else if (ratio <= 0.125) return 'ğŸŒ˜'; 
else if (ratio <= 0.25) return 'ğŸŒ—';  
else if (ratio <= 0.375) return 'ğŸŒ–'; 
else if (ratio <= 0.5) return 'ğŸŒ•';   
else if (ratio <= 0.625) return 'ğŸŒ”'; 
else if (ratio <= 0.75) return 'ğŸŒ“';  
else if (ratio <= 0.875) return 'ğŸŒ’'; 
else return 'ğŸŒ‘';                     
}
generateSingleChar(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
if (!char.trim()) return [];
const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
const baseFontSize = Math.max(sizeParam * 5, 50); 
const canvasWidth = baseFontSize * 2;   
const canvasHeight = baseFontSize * 2;  
const canvas = document.createElement('canvas');
canvas.width = canvasWidth;
canvas.height = canvasHeight;
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = 'black';
ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const x = canvas.width / 2;
const y = canvas.height / 2;
ctx.fillText(char, x, y);
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const pixelMatrix = [];
for (let y = 0; y < canvas.height; y++) {
pixelMatrix[y] = [];
for (let x = 0; x < canvas.width; x++) {
const idx = (y * canvas.width + x) * 4;
const gray = 0.299 * imageData.data[idx] + 
0.587 * imageData.data[idx + 1] + 
0.114 * imageData.data[idx + 2];
pixelMatrix[y][x] = this.grayToColorLevel(gray);
}
}
let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
let foundText = false;
for (let y = 0; y < canvas.height; y++) {
for (let x = 0; x < canvas.width; x++) {
if (pixelMatrix[y][x] === 0) {
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
foundText = true;
}
}
}
if (!foundText) {
if (isVertical) {
const defaultLine = 'ğŸŒ•'.repeat(sizeParam);
return [defaultLine, defaultLine, defaultLine];
} else {
const result = [];
for (let i = 0; i < sizeParam; i++) {
result.push('ğŸŒ•ğŸŒ•ğŸŒ•');
}
return result;
}
}
const charWidth = maxX - minX + 1;
const charHeight = maxY - minY + 1;
let targetPixelWidth, targetPixelHeight;
if (isVertical) {
targetPixelWidth = sizeParam * 5;
targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
} else {
targetPixelHeight = sizeParam * 5;
targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
}
const gridSize = 5;
const resultLines = [];
for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
let line = '';
for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
const subGrid = [];
for (let dy = 0; dy < 5; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < 5; dx++) {
const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
} else {
subGrid[dy][dx] = 1; 
}
}
}
line += this.gridToMoon(subGrid);
}
resultLines.push(line);
}
return resultLines;
}
combineVertically(charResults, spacing, sizeParam) {
if (charResults.length === 0) return '';
let combinedLines = [];
for (let i = 0; i < charResults.length; i++) {
const charLines = charResults[i];
combinedLines.push(...charLines);
if (i < charResults.length - 1 && spacing > 0) {
const spacingLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
for (let j = 0; j < spacing; j++) {
combinedLines.push(spacingLine);
}
}
}
return combinedLines.join('\n');
}
combineHorizontally(charResults, spacing, sizeParam) {
if (charResults.length === 0) return '';
const maxLines = Math.max(...charResults.map(result => result.length));
const normalizedResults = charResults.map(result => {
const normalized = [...result];
const emptyLine = 'ğŸŒ‘'.repeat(sizeParam || 10);
while (normalized.length < maxLines) {
normalized.push(emptyLine);
}
return normalized;
});
const finalLines = [];
for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
let combinedLine = '';
for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
combinedLine += normalizedResults[charIndex][lineIndex];
if (charIndex < normalizedResults.length - 1 && spacing > 0) {
combinedLine += 'ğŸŒ‘'.repeat(spacing);
}
}
finalLines.push(combinedLine);
}
return finalLines.join('\n');
}
generateSingleCharWithMeta(char, sizeParam = 20, fontType = 'custom', isVertical = true) {
if (!char.trim()) return [];
const fontFamily = FONT_FAMILIES[fontType] || FONT_FAMILIES['default'];
const baseFontSize = Math.max(sizeParam * 5, 50);
const canvasWidth = baseFontSize * 2;
const canvasHeight = baseFontSize * 2;
const canvas = document.createElement('canvas');
canvas.width = canvasWidth;
canvas.height = canvasHeight;
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = 'black';
ctx.font = `bold ${baseFontSize}px ${fontFamily}`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const x = canvas.width / 2;
const y = canvas.height / 2;
ctx.fillText(char, x, y);
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const pixelMatrix = [];
for (let y = 0; y < canvas.height; y++) {
pixelMatrix[y] = [];
for (let x = 0; x < canvas.width; x++) {
const idx = (y * canvas.width + x) * 4;
const gray = 0.299 * imageData.data[idx] + 
0.587 * imageData.data[idx + 1] + 
0.114 * imageData.data[idx + 2];
pixelMatrix[y][x] = this.grayToColorLevel(gray);
}
}
let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
let foundText = false;
for (let y = 0; y < canvas.height; y++) {
for (let x = 0; x < canvas.width; x++) {
if (pixelMatrix[y][x] === 0) {
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
foundText = true;
}
}
}
if (!foundText) {
const defaultSize = isVertical ? [sizeParam, 3] : [3, sizeParam];
const defaultGrid = [];
for (let row = 0; row < defaultSize[1]; row++) {
defaultGrid[row] = [];
for (let col = 0; col < defaultSize[0]; col++) {
defaultGrid[row][col] = this.gridToMoonWithMeta(Array(5).fill().map(() => Array(5).fill(0)));
}
}
return defaultGrid;
}
const charWidth = maxX - minX + 1;
const charHeight = maxY - minY + 1;
let targetPixelWidth, targetPixelHeight;
if (isVertical) {
targetPixelWidth = sizeParam * 5;
targetPixelHeight = Math.ceil((charHeight * targetPixelWidth) / charWidth);
targetPixelHeight = Math.ceil(targetPixelHeight / 5) * 5;
} else {
targetPixelHeight = sizeParam * 5;
targetPixelWidth = Math.ceil((charWidth * targetPixelHeight) / charHeight);
targetPixelWidth = Math.ceil(targetPixelWidth / 5) * 5;
}
const gridSize = 5;
const metaGrid = [];
for (let targetY = 0; targetY < targetPixelHeight; targetY += gridSize) {
const metaRow = [];
for (let targetX = 0; targetX < targetPixelWidth; targetX += gridSize) {
const subGrid = [];
for (let dy = 0; dy < 5; dy++) {
subGrid[dy] = [];
for (let dx = 0; dx < 5; dx++) {
const sourceX = minX + Math.round((targetX + dx) * charWidth / targetPixelWidth);
const sourceY = minY + Math.round((targetY + dy) * charHeight / targetPixelHeight);
if (sourceY >= 0 && sourceY < canvas.height && sourceX >= 0 && sourceX < canvas.width) {
subGrid[dy][dx] = pixelMatrix[sourceY][sourceX];
} else {
subGrid[dy][dx] = 1; 
}
}
}
metaRow.push(this.gridToMoonWithMeta(subGrid));
}
metaGrid.push(metaRow);
}
return metaGrid;
}
generate(text, sizeParam = 20, fontType = 'custom', isVertical = true, reverseColor = false, spacing = 0, enableVerticalProcessing = true, padding = 0) {
if (!text.trim()) return '';
const chars = Array.from(text);
if (enableVerticalProcessing) {
const charMetaResults = chars.map(char => {
return this.generateSingleCharWithMeta(char, sizeParam, fontType, isVertical);
});
let globalMetaGrid = [];
let maxCharWidth = 0;
if (isVertical) {
for (let charIndex = 0; charIndex < charMetaResults.length; charIndex++) {
const charMeta = charMetaResults[charIndex];
maxCharWidth = Math.max(maxCharWidth, charMeta[0]?.length || 0);
globalMetaGrid.push(...charMeta);
if (charIndex < charMetaResults.length - 1 && spacing > 0) {
for (let s = 0; s < spacing; s++) {
const spacingRow = [];
for (let col = 0; col < (charMeta[0]?.length || sizeParam); col++) {
spacingRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
globalMetaGrid.push(spacingRow);
}
}
}
} else {
const maxLines = Math.max(...charMetaResults.map(result => result.length));
const normalizedResults = charMetaResults.map(result => {
const normalized = [...result];
const charWidth = result[0]?.length || sizeParam;
while (normalized.length < maxLines) {
const emptyRow = [];
for (let col = 0; col < charWidth; col++) {
emptyRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
normalized.push(emptyRow);
}
return normalized;
});
for (let lineIndex = 0; lineIndex < maxLines; lineIndex++) {
const combinedRow = [];
for (let charIndex = 0; charIndex < normalizedResults.length; charIndex++) {
combinedRow.push(...normalizedResults[charIndex][lineIndex]);
if (charIndex < normalizedResults.length - 1 && spacing > 0) {
for (let s = 0; s < spacing; s++) {
combinedRow.push({
originalMoonPhase: 'ğŸŒ‘',
finalMoonPhase: 'ğŸŒ‘',
densityLevel: 'æä½å¯†åº¦',
densitySymbol: 'â¬›',
bias: 'balanced',
blackCount: 0,
centerX: 2
});
}
}
}
globalMetaGrid.push(combinedRow);
}
}
const targetDensityLevels = [];
if (document.getElementById('verticalMedium').checked) {
targetDensityLevels.push('ä¸­ç­‰å¯†åº¦');
}
if (document.getElementById('verticalHigh').checked) {
targetDensityLevels.push('æ¬¡é«˜å¯†åº¦');
}
const thresholdN = 2; 
globalMetaGrid = this.applyVerticalProcessing(globalMetaGrid, targetDensityLevels, thresholdN);
let avoidCount = 0, keepCount = 0;
this.verticalProcessingPositions.forEach(pos => {
if (pos.row < globalMetaGrid.length && pos.col < globalMetaGrid[pos.row].length) {
const cell = globalMetaGrid[pos.row][pos.col];
if (cell.finalMoonPhase === 'ğŸŒ‘') {
avoidCount++;
} else if (cell.finalMoonPhase === 'ğŸŒ•') {
keepCount++;
}
}
});
const resultLines = globalMetaGrid.map(row => 
row.map(cell => cell.finalMoonPhase).join('')
);
let result = resultLines.join('\n');
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
} else {
const charResults = chars.map(char => {
return this.generateSingleChar(char, sizeParam, fontType, isVertical);
});
let result;
if (isVertical) {
result = this.combineVertically(charResults, spacing, sizeParam);
} else {
result = this.combineHorizontally(charResults, spacing, sizeParam);
}
if (padding > 0) {
result = this.applyPadding(result, padding);
}
return result;
}
}
}
const FONT_FAMILIES = {
'default': 'sans-serif',
'gothic': '"ãƒ¡ã‚¤ãƒªã‚ª", "Meiryo", "Hiragino Kaku Gothic ProN", "æ¸¸ã‚´ã‚·ãƒƒã‚¯", "Yu Gothic", "MS Pã‚´ã‚·ãƒƒã‚¯", "MS PGothic", sans-serif',
'mincho': '"æ¸¸æ˜æœ", "Yu Mincho", "Hiragino Mincho ProN", "MS æ˜æœ", "MS Mincho", serif'
};
const FONT_CONFIGS = {
'default': { 
adhesionCoefficient: 2,
verticalDensityLevels: ['ä¸­ç­‰å¯†åº¦', 'æ¬¡é«˜å¯†åº¦']
},
'gothic': { 
adhesionCoefficient: 2,
verticalDensityLevels: ['ä¸­ç­‰å¯†åº¦', 'æ¬¡é«˜å¯†åº¦']
},
'mincho': { 
adhesionCoefficient: 3,
verticalDensityLevels: []  
}
};
const generator = new SimpleMoonGenerator();
const horizontalEnhancer = new HorizontalEnhancer();
function updateSliderLabel() {
const isVertical = document.querySelector('input[name="textDirection"]:checked').value === 'vertical';
const sliderLabel = document.getElementById('sliderLabel');
const sliderUnit = document.getElementById('sliderUnit');
if (isVertical) {
sliderLabel.textContent = 'å¹…æ–‡å­—æ•°';
sliderUnit.textContent = 'æ–‡å­—';
} else {
sliderLabel.textContent = 'é«˜ã•';
sliderUnit.textContent = 'è¡Œ';
}
}
function copyToClipboard() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
navigator.clipboard.writeText(moonArt).then(() => {
const copyBtn = document.getElementById('copyBtn');
const btnText = copyBtn.querySelector('.btn-text');
const originalText = btnText.textContent;
btnText.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼';
copyBtn.classList.add('success');
setTimeout(() => {
btnText.textContent = originalText;
copyBtn.classList.remove('success');
}, 2000);
}).catch(err => {
});
}
function downloadText() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
const randomId = Math.random().toString(36).substring(2, 8);
const filename = `moon-art-${randomId}-${Date.now()}.txt`;
const blob = new Blob([moonArt], { type: 'text/plain;charset=utf-8' });
const url = URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.click();
URL.revokeObjectURL(url);
}
function downloadImage() {
const moonArt = document.getElementById('moonArt').textContent;
if (!moonArt || moonArt.includes('å…¥åŠ›ã—ã¦ãã ã•ã„') || moonArt.includes('ã‚¨ãƒ©ãƒ¼')) return;
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
const lines = moonArt.split('\n');
const fontSize = 20;
const lineHeight = fontSize;
canvas.width = lines[0].length * fontSize / 2;
canvas.height = lines.length * lineHeight;
ctx.fillStyle = 'black';
ctx.font = `${fontSize}px sans-serif`;
ctx.textBaseline = 'top';
lines.forEach((line, lineIndex) => {
let x = 0;
for (let i = 0; i < line.length; i += 2) {
const emoji = line.substr(i, 2);
ctx.fillText(emoji, x, lineIndex * lineHeight);
x += fontSize;
}
});
const randomId = Math.random().toString(36).substring(2, 8);
const filename = `moon-art-${randomId}-${Date.now()}.png`;
canvas.toBlob((blob) => {
const url = URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.click();
URL.revokeObjectURL(url);
}, 'image/png');
}
function updatePreview() {
if (currentInputMode === 'image' && lastUploadedImageSrc) {
generateFromImage(lastUploadedImageSrc);
} else if (currentInputMode === 'text') {
updateTextPreview();
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
}
}
function updateTextPreview() {
const text = document.getElementById('textInput').value.trim();
const sizeValue = parseInt(document.getElementById('heightSlider').value);
const fontType = document.getElementById('fontSelect').value;
const adhesionCoefficient = parseInt(document.getElementById('adhesionSlider').value);
const spacing = parseInt(document.getElementById('spacingSlider').value);
const padding = parseInt(document.getElementById('paddingSlider').value);
const selectedRadio = document.querySelector('input[name="textDirection"]:checked');
const isVertical = selectedRadio?.value === 'vertical';
const reverseColor = document.getElementById('reverseColor').checked;
const enableDenoising = document.getElementById('enableDenoising').checked;
if (!text) {
document.getElementById('moonArt').textContent = '';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
return;
}
try {
let result = generator.generate(text, sizeValue, fontType, isVertical, false, spacing, true, padding); 
if (generator.verticalProcessingPositions.length > 0) {
const lines = result.split('\n');
generator.verticalProcessingPositions.forEach(pos => {
if (pos.row < lines.length && pos.col < lines[pos.row].length) {
const char = Array.from(lines[pos.row])[pos.col];
}
});
}
horizontalEnhancer.setAdhesionCoefficient(adhesionCoefficient);
horizontalEnhancer.setEnableDenoising(enableDenoising);
result = horizontalEnhancer.enhance(result);
if (generator.verticalProcessingPositions.length > 0) {
const linesFinal = result.split('\n');
let moon_count = 0, black_count = 0;
generator.verticalProcessingPositions.forEach(pos => {
if (pos.row < linesFinal.length && pos.col < linesFinal[pos.row].length) {
const charFinal = Array.from(linesFinal[pos.row])[pos.col];
if (charFinal === 'ğŸŒ•') moon_count++;
else if (charFinal === 'ğŸŒ‘') black_count++;
}
});
const allChars = result.replace(/\n/g, '');
const totalMoon = (allChars.match(/ğŸŒ•/g) || []).length;
const totalBlack = (allChars.match(/ğŸŒ‘/g) || []).length;
}
if (reverseColor) {
result = Array.from(result).map(char => {
if (char === '\n') return char;
return generator.reverseMoon(char);
}).join('');
}
document.getElementById('moonArt').textContent = result;
document.getElementById('actionButtons').style.display = 'flex';
} catch (error) {
document.getElementById('moonArt').textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
document.getElementById('actionButtons').style.display = 'none';
document.getElementById('debugInfo').style.display = 'none';
}
}
function debounce(func, wait) {
let timeout;
return function executedFunction(...args) {
const later = () => {
clearTimeout(timeout);
func(...args);
};
clearTimeout(timeout);
timeout = setTimeout(later, wait);
};
}
function throttle(func, limit) {
let inThrottle;
return function(...args) {
if (!inThrottle) {
func(...args);
inThrottle = true;
setTimeout(() => inThrottle = false, limit);
}
};
}
function isMobileDevice() {
return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
(navigator.maxTouchPoints && navigator.maxTouchPoints > 1) ||
window.innerWidth <= 768;
}
document.addEventListener('DOMContentLoaded', () => {
const heightSlider = document.getElementById('heightSlider');
const heightValue = document.getElementById('heightValue');
const adhesionSlider = document.getElementById('adhesionSlider');
const adhesionValue = document.getElementById('adhesionValue');
const spacingSlider = document.getElementById('spacingSlider');
const spacingValue = document.getElementById('spacingValue');
const updateHeightPreview = throttle(() => {
heightValue.textContent = heightSlider.value;
if (currentInputMode === 'text') {
textModeSettings.height = parseInt(heightSlider.value);
} else {
imageModeSettings.height = parseInt(heightSlider.value);
}
updatePreview();
}, 100);
heightSlider.addEventListener('input', updateHeightPreview);
const updateAdhesionPreview = throttle(() => {
adhesionValue.textContent = adhesionSlider.value;
updatePreview();
}, 100);
adhesionSlider.addEventListener('input', updateAdhesionPreview);
const updateSpacingPreview = throttle(() => {
spacingValue.textContent = spacingSlider.value;
updatePreview();
}, 100);
spacingSlider.addEventListener('input', updateSpacingPreview);
const paddingSlider = document.getElementById('paddingSlider');
const paddingValue = document.getElementById('paddingValue');
const updatePaddingPreview = throttle(() => {
paddingValue.textContent = paddingSlider.value;
if (currentInputMode === 'text') {
textModeSettings.padding = parseInt(paddingSlider.value);
} else {
imageModeSettings.padding = parseInt(paddingSlider.value);
}
updatePreview();
}, 100);
paddingSlider.addEventListener('input', updatePaddingPreview);
document.getElementById('textInput').addEventListener('input', debounce(updatePreview, 300));
document.getElementById('fontSelect').addEventListener('change', (e) => {
const fontType = e.target.value;
const config = FONT_CONFIGS[fontType] || FONT_CONFIGS['default'];
adhesionSlider.value = config.adhesionCoefficient;
adhesionValue.textContent = config.adhesionCoefficient;
document.getElementById('verticalMedium').checked = 
config.verticalDensityLevels.includes('ä¸­ç­‰å¯†åº¦');
document.getElementById('verticalHigh').checked = 
config.verticalDensityLevels.includes('æ¬¡é«˜å¯†åº¦');
updatePreview();
});
document.getElementById('showDebugCanvas').addEventListener('change', updatePreview);
document.querySelectorAll('input[name="textDirection"]').forEach(radio => {
radio.addEventListener('change', () => {
updateSliderLabel(); 
updatePreview(); 
});
});
document.getElementById('reverseColor').addEventListener('change', updatePreview);
document.getElementById('verticalMedium').addEventListener('change', updatePreview);
document.getElementById('verticalHigh').addEventListener('change', updatePreview);
document.getElementById('enableDenoising').addEventListener('change', updatePreview);
document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
document.getElementById('downloadTextBtn').addEventListener('click', downloadText);
document.getElementById('downloadImageBtn').addEventListener('click', downloadImage);
if (!isMobileDevice()) {
document.getElementById('bookmarkBtn').addEventListener('click', addBookmark);
} else {
const bookmarkBtn = document.getElementById('bookmarkBtn');
if (bookmarkBtn) {
bookmarkBtn.style.display = 'none';
}
}
const currentSelection = document.querySelector('input[name="textDirection"]:checked');
if (!currentSelection) {
if (isMobileDevice()) {
document.querySelector('input[name="textDirection"][value="vertical"]').checked = true;
} else {
document.querySelector('input[name="textDirection"][value="horizontal"]').checked = true;
}
updateSliderLabel();
}
const defaultFontType = document.getElementById('fontSelect').value;
const defaultConfig = FONT_CONFIGS[defaultFontType] || FONT_CONFIGS['default'];
adhesionSlider.value = defaultConfig.adhesionCoefficient;
adhesionValue.textContent = defaultConfig.adhesionCoefficient;
setTimeout(() => {
updateSliderLabel();
updatePreview();
}, 0);
setupFooterLinks();
initializeTabs();
initializeImageUpload();
});
function initializeTabs() {
const tabButtons = document.querySelectorAll('.tab-button');
const tabContents = document.querySelectorAll('.tab-content');
tabButtons.forEach(button => {
button.addEventListener('click', () => {
const tabId = button.getAttribute('data-tab');
tabButtons.forEach(btn => btn.classList.remove('active'));
tabContents.forEach(content => content.classList.remove('active'));
button.classList.add('active');
if (tabId === 'text') {
document.getElementById('textTab').classList.add('active');
if (currentInputMode === 'image') {
imageModeSettings.height = parseInt(document.getElementById('heightSlider').value);
imageModeSettings.padding = parseInt(document.getElementById('paddingSlider').value);
}
currentInputMode = 'text'; 
const heightSlider = document.getElementById('heightSlider');
const heightMaxLabel = heightSlider.nextElementSibling;
heightSlider.max = 60;
heightMaxLabel.textContent = '60';
heightSlider.value = textModeSettings.height;
document.getElementById('heightValue').textContent = textModeSettings.height;
document.getElementById('paddingSlider').value = textModeSettings.padding;
document.getElementById('paddingValue').textContent = textModeSettings.padding;
const textInput = document.getElementById('textInput').value.trim();
if (textInput) {
updatePreview();
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('debugInfo').style.display = 'none';
document.getElementById('actionButtons').style.display = 'none';
}
} else if (tabId === 'image') {
document.getElementById('imageTab').classList.add('active');
if (currentInputMode === 'text') {
textModeSettings.height = parseInt(document.getElementById('heightSlider').value);
textModeSettings.padding = parseInt(document.getElementById('paddingSlider').value);
}
currentInputMode = 'image'; 
const heightSlider = document.getElementById('heightSlider');
const heightMaxLabel = heightSlider.nextElementSibling;
heightSlider.max = 500;
heightMaxLabel.textContent = '500';
heightSlider.value = imageModeSettings.height;
document.getElementById('heightValue').textContent = imageModeSettings.height;
document.getElementById('paddingSlider').value = imageModeSettings.padding;
document.getElementById('paddingValue').textContent = imageModeSettings.padding;
if (lastUploadedImageSrc) {
updatePreview();
} else {
document.getElementById('moonArt').textContent = '';
document.getElementById('debugInfo').style.display = 'none';
document.getElementById('actionButtons').style.display = 'none';
}
}
});
});
}
function initializeImageUpload() {
const imageInput = document.getElementById('imageInput');
const uploadButton = document.getElementById('uploadButton');
const uploadArea = document.getElementById('imageUploadArea');
const imagePreview = document.getElementById('imagePreview');
const previewImg = document.getElementById('previewImg');
const imageInfo = document.getElementById('imageInfo');
const removeButton = document.getElementById('removeImage');
uploadButton.addEventListener('click', () => {
imageInput.click();
});
uploadArea.addEventListener('click', (e) => {
if (e.target === uploadArea || e.target.classList.contains('upload-icon') || 
e.target.classList.contains('upload-text') || e.target.classList.contains('upload-hint')) {
imageInput.click();
}
});
imageInput.addEventListener('change', handleFileSelect);
uploadArea.addEventListener('dragover', (e) => {
e.preventDefault();
uploadArea.classList.add('dragover');
});
uploadArea.addEventListener('dragleave', (e) => {
e.preventDefault();
uploadArea.classList.remove('dragover');
});
uploadArea.addEventListener('drop', (e) => {
e.preventDefault();
uploadArea.classList.remove('dragover');
const files = e.dataTransfer.files;
if (files.length > 0 && files[0].type.startsWith('image/')) {
handleFile(files[0]);
}
});
removeButton.addEventListener('click', () => {
imageInput.value = '';
uploadArea.style.display = 'flex';
imagePreview.style.display = 'none';
lastUploadedImageSrc = null;
document.getElementById('moonArt').textContent = '';
document.getElementById('debugInfo').style.display = 'none';
document.getElementById('actionButtons').style.display = 'none';
});
function handleFileSelect(e) {
const file = e.target.files[0];
if (file && file.type.startsWith('image/')) {
handleFile(file);
}
}
function handleFile(file) {
const reader = new FileReader();
reader.onload = (e) => {
previewImg.src = e.target.result;
imageInfo.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
uploadArea.style.display = 'none';
imagePreview.style.display = 'block';
lastUploadedImageSrc = e.target.result;
currentInputMode = 'image';
setTimeout(() => {
generateFromImage(e.target.result);
}, 100);
};
reader.readAsDataURL(file);
}
}
async function generateFromImage(imageSrc) {
try {
document.getElementById('moonArt').textContent = 'å‡¦ç†ä¸­...';
const height = parseInt(document.getElementById('heightSlider').value);
const padding = parseInt(document.getElementById('paddingSlider').value);
const reverseColor = document.getElementById('reverseColor').checked;
const enableDenoising = document.getElementById('enableDenoising').checked;
const adhesionCoefficient = parseInt(document.getElementById('adhesionSlider').value);
const imageProcessor = new ImageProcessor();
const imageData = await imageProcessor.loadAndProcessImage(imageSrc, height, true);
const generator = new SimpleMoonGenerator();
let result = generator.generateFromImage(
imageData.matrix,
imageData.width,
imageData.height,
padding 
);
if (reverseColor) {
result = result.split('\n').map(line => {
return Array.from(line).map(char => {
return generator.reverseMoon(char);
}).join('');
}).join('\n');
}
document.getElementById('moonArt').textContent = result;
document.getElementById('actionButtons').style.display = 'flex';
document.getElementById('debugInfo').style.display = 'none';
} catch (error) {
document.getElementById('moonArt').textContent = 'ã‚¨ãƒ©ãƒ¼: ç”»åƒã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ';
document.getElementById('actionButtons').style.display = 'none';
}
}
function addBookmark() {
const title = 'æœˆæ–‡å­—ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ - MojiMoon';
const url = 'https://mojimoon.com';
try {
if (navigator.userAgent.indexOf('Chrome') > -1 || navigator.userAgent.indexOf('Safari') > -1) {
const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
const shortcut = isMac ? 'Cmd+D' : 'Ctrl+D';
alert(`${shortcut} ã‚’æŠ¼ã—ã¦ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¦ãã ã•ã„ğŸŒ™`);
} else if (window.sidebar && window.sidebar.addPanel) {
window.sidebar.addPanel(title, url, '');
} else if (window.external && window.external.AddFavorite) {
window.external.AddFavorite(url, title);
} else {
const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
const shortcut = isMac ? 'Cmd+D' : 'Ctrl+D';
alert(`${shortcut} ã‚’æŠ¼ã—ã¦ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã—ã¦ãã ã•ã„`);
}
} catch (error) {
alert('ãŠæ°—ã«å…¥ã‚Šã«è¿½åŠ ã™ã‚‹ã«ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰æ“ä½œã—ã¦ãã ã•ã„ã€‚');
}
}
function setupFooterLinks() {
const footerLinks = document.querySelectorAll('.footer a');
footerLinks.forEach(link => {
link.addEventListener('mouseenter', function() {
this.style.transform = 'translateY(-2px)';
this.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
});
link.addEventListener('mouseleave', function() {
this.style.transform = 'translateY(0)';
this.style.boxShadow = 'none';
});
});
}
</script>
<div class="mobile-footer-nav">
<a href="guide.html" class="guide-link">ğŸ“– ä½¿ç”¨ã‚¬ã‚¤ãƒ‰</a>
<a href="index_en.html" class="lang-switcher">ğŸŒ English</a>
</div>
<footer class="footer">
<div class="container">
<h2 style="text-align: center; margin-bottom: 20px; font-size: 1.3rem; font-weight: 600; color: #374151;">ğŸ“š é–¢é€£ã‚³ãƒ³ãƒ†ãƒ³ãƒ„</h2>
<div style="text-align: center; padding: 10px 0;">
<a href="line_input.html" class="btn-footer btn-cyan">
ğŸ’¬ LINEå°‚ç”¨ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼
</a>
<a href="line.html" class="btn-footer btn-green">
ğŸ“± LINEæœˆæ–‡å­—å®Œå…¨æ´»ç”¨ã‚¬ã‚¤ãƒ‰
</a>
<a href="guide.html" class="btn-footer btn-blue">
ğŸ“– ä½¿ç”¨ã‚¬ã‚¤ãƒ‰
</a>
</div>
<p style="text-align: center; margin-top: 30px; font-size: 0.85rem; color: #9ca3af;">
å‹æƒ…ãƒªãƒ³ã‚¯:
<a href="https://genhub.jp/" target="_blank" rel="noopener" class="friend-link">genhub</a> |
<a href="https://kidsai.art/" target="_blank" rel="noopener" class="friend-link">kidsai</a> |
<a href="https://prompta.jp/" target="_blank" rel="noopener" class="friend-link">prompta</a>
</p>
</div>
</footer>
</body>
</html>
